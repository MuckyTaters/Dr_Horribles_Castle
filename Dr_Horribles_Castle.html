<!//////////////////////////////////////////
//  --- DR. HORRIBLE'S CASTLE ---
//
//  Copyright (c) Muckytaters 2024
//
//  This program is free software: you can
//  redistribute it and/or modify it under 
//  the terms of the GNU General Public License
//  as published by the Free Software Foundation,
//  either version 3 of the License, or (at your
//  option) any later version.
//
//  This program is distributed in the hope it
//  will be useful, but WITHOUT ANY WARRANTY;
//  without even the implied warranty of MERCHANTABILITY
//  or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU
//  General Public License along with this
//  program. If not, see http://www.gnu.org/license
////////////////////////////////////////////>

<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<title>DR. HORRIBLE'S CASTLE</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script>
onload = function(){

    ///////////////////////////////////////////
    // PROMPT USER BEFORE PAGE REFRESH/CLOSE
    window.addEventListener(
        'beforeunload',
        (event) => {
            event.preventDefault();
            event.returnValue = '';
        }
    );

    ///////////////////////////////////////////
    // BITwISE CONSTANTS (DO NOT AMMEND)
    const SOLID_LEFT = 1;
    const SOLID_RIGHT = 2;
    const SOLID_TOP = 4;
    const SOLID_BOTTOM = 8;
    const SOLID_ALL = SOLID_LEFT | SOLID_RIGHT | SOLID_TOP | SOLID_BOTTOM;

    ///////////////////////////////////////////
    // DIRECTION CONSTANTS (DO NOT AMMEND)
    const DIR_UP = 0;
    const DIR_LEFT = 1;
    const DIR_DOWN = 2;
    const DIR_RIGHT = 3;
    const DIR_NONE = 4;
    const DIR_REVERSE= [
        DIR_DOWN,
        DIR_RIGHT,
        DIR_UP,
        DIR_LEFT,
        DIR_NONE
    ];
    const DIR_90_CLOCKWISE = [
        DIR_RIGHT,
        DIR_UP,
        DIR_LEFT,
        DIR_DOWN,
        DIR_NONE
    ];
    const DIR_90_ANTI_CLOCKWISE = [
        DIR_LEFT,
        DIR_DOWN,
        DIR_RIGHT,
        DIR_UP,
        DIR_NONE
    ];

    ///////////////////////////////////////////
    // INITIAL DECLARATIONS & PREP
    
    // TO BE DEFUNCT
    const BORDER_WIDTH_IN_CHARS = 2;
    const BORDER_HEIGHT_IN_CHARS = 1.5;

    // BASIC WINDOW/TIME CHARACTERISTICS
    const CHARS_WIDE = 24;
    const CHARS_HIGH = 16;
    const PX_PER_CHAR_HOZ = 8;
    const PX_PER_CHAR_VERT = 8;
    const FRAME_RATE = 30;
    const PLAYER_START_LIVES = 5;

    // ASCII CODES (SEE MORE IN LEVEL DESIGN SECTION)
    const INVALID_ASCII = 8;
    const PLAYER_CHAR_ASCII = 251;
    const TICK_ASCII = 226;
    const CROSS_ASCII = 227;
    const DR_H_ASCII = 241;
    const FX_ONLY_ASCII = 248;
    const NO_MUTE_ASCII = 249;
    const MUTE_ASCII = 250;

    // Get current window dimensions
    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;

    // Calculate number of virtual pixels
    const PIXELS_WIDE = CHARS_WIDE * PX_PER_CHAR_HOZ;
    const PIXELS_HIGH = CHARS_HIGH * PX_PER_CHAR_VERT;

    // Calculate best size for virtual pixels
    const PIXEL_WIDTH = Math.floor( WIDTH / PIXELS_WIDE );  
    const PIXEL_HEIGHT
        = Math.floor( 
            HEIGHT / ( PIXELS_HIGH + 1 * PX_PER_CHAR_VERT )
        );  
    
    // And then character width
    const CHAR_WIDTH = PIXEL_WIDTH * PX_PER_CHAR_HOZ;
    const CHAR_HEIGHT = PIXEL_HEIGHT * PX_PER_CHAR_VERT;

    // Calculate frame duration in milliseconds
    const FRAME_DURATION = Math.floor( 1000 / FRAME_RATE );

    // Colo(u)r definitions
    // Note: see level design section for enemy colo(u)r defs
    const DEFAULT_BG_COL = 'black';
    const DEFAULT_FG_COL = 'white';
    const PLAYER_COL = 'orange';
    const DR_H_COL = 'red';
    const DEFAULT_BORDER_COL = 'purple';
    const FLASH_BORDER_COL = 'cyan';
    const STAT_BG_COL = 'purple';
    const STAT_LIVES_COL = 'orange'; 
    const STAT_NUM_COL = 'white'; 
    const STAT_TIMER_FG_COL = 'red'; 
    const STAT_TIMER_BG_COL = 'white'; 
    const STAT_ALERT_FG_COL = 'black';
    const STAT_ALERT_BG_COL = 'cyan';

    // Declare (empty) 2D arrays to hold characters
    const chars = [];  // Main play area
    const sb_chars = [];  // Stat bar

    // Create (empty) array to keep a reference to all sprites
    let all_sprites = [];

    // Create (empty) array to keep a reference to enemy sprites
    let enemy_sprites = [];

    // Create (initially zero) variable to store main loop interval ID;
    let main_loop_interval_id = 0;

    // Flag to track if key handler is on
    let key_handler_on = false;

    // Enumerate game states
    const GAME_STATE_TITLE = 0;
    const GAME_STATE_BLERB = 1;
    const GAME_STATE_MENU = 2;
    const GAME_STATE_INSTRUCTIONS_1 = 3;
    const GAME_STATE_INSTRUCTIONS_2 = 4;
    const GAME_STATE_INSTRUCTIONS_3 = 5;
    const GAME_STATE_SELECT_LEVEL = 6;
    const GAME_STATE_ABOUT = 7;
    const GAME_STATE_LEVEL_INTRO = 8;
    const GAME_STATE_BUILDING_LEVEL = 9;
    const GAME_STATE_IN_PLAY = 10;
    const GAME_STATE_PLAY_PAUSED = 11;
    const GAME_STATE_QUIT_OPTION = 12;
    const GAME_STATE_RESTART_OPTION = 13;
    const GAME_STATE_LOST_LIFE = 14;
    const GAME_STATE_COMPLETED_LEVEL = 15;
    const GAME_STATE_BONUS_FINISHED = 16;
    const GAME_STATE_HIT_ANY_KEY_TO_PLAY = 17;
    const GAME_STATE_GAME_OVER = 18;
    const GAME_STATE_GAME_COMPLETED_WITH_CHEATS = 19;
    const GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS = 20;
    const GAME_STATE_GAME_COMPLETED_SEQUENCE = 21;
    const GAME_STATE_AWAITING_MOUSE_CLICK = 22;
    const GAME_STATE_MAX = 23;

    // Enumerate mute states
    const MUTE_STATUS_FULL_AUDIO = 0;
    const MUTE_STATUS_FX_ONLY = 1;
    const MUTE_STATUS_MUTE_ALL = 2;
    const MUTE_STATUS_MAX = 3;

    // Stat bar parameters
    const STAT_BAR_EMPTY_ASCII = 32;
    const STAT_BAR_LEVEL_DIGITS = 2;
    const STAT_BAR_LIVES_MAX = 7;
    const STAT_BAR_SCORE_DIGITS = 5;
    const STAT_BAR_TIMER_DIGITS = 3;
    const STAT_BAR_TIMER_INTERVAL_IN_MS = 3000;

    // Non-printable ASCII characters
    const CHAR_COPYRIGHT = String.fromCharCode( 255 );
    const CHAR_UP = String.fromCharCode( 221 );
    const CHAR_LEFT = String.fromCharCode( 224 );
    const CHAR_DOWN = String.fromCharCode( 223 );
    const CHAR_RIGHT = String.fromCharCode( 222 );

    // Length (in milliseconds) of short delay
    // before checking for key entry 
    const KEY_ENTRY_DELAY = 50;

    // Length (in milliseconds) of delay after
    // player loses life
    const ACTION_PAUSE_DELAY = 1000;

    //! Flag used to delay key response
    let key_handling_delay = false;    

    // Track current game state
    let game_state = GAME_STATE_TITLE; 

    // Track audio mute status
    let audio_mute = MUTE_STATUS_FULL_AUDIO;

    // Track current level number
    let current_level = 0;

    // Track highest level achieved
    let max_level_achieved = 0;

    // Remember start level
    let start_level = 0;

    // Track player lives left
    let player_lives = PLAYER_START_LIVES;

    // Level timer (seconds left to complete level)
    let level_timer = 0;
    
    // Starting value of level timer
    let level_timer_max = 0;

    // Level timer reference ticks (used to calc value of timer)
    let level_timer_reference_ticks = 0;

    // Time (in ms) spent in pause mode this level
    let level_pause_total_ticks = 0;

    // Remember ticks when game put into pause mode
    let level_pause_ticks = 0;

    // Remember player start position
    let player_start_char_i= 0;
    let player_start_char_j = 0;

    // Remember 1st digit used to select level
    const NO_DIGIT_SELECTED = -1;
    let select_level_first_digit = NO_DIGIT_SELECTED;

    // Remember 1st and 2nd letters used to enter cheat code
    let cheat_code_first_alpha = NO_DIGIT_SELECTED;
    let cheat_code_second_alpha = NO_DIGIT_SELECTED;

    // Create (initially NULL) reference to 'div' to hold
    // all sprite 'div's
    let top_sprite_div = 0;

    // Create (initially NULL) reference to player sprite
    let player_sprite = 0;

    // Create player score
    // Note: this is not a member of 'player_sprite' object
    //       because this value transcends individual levels,
    //       and 'player_sprite' is recreated with every level.
    let player_score = 0;

    // Create player high score
    let player_hi_score = 0;

    // Keep track of milliseconds at *previous* animation frame
    // Note: negative value indicates there is no previous frame
    let prev_ticks = -1;

    // Create set to hold all uncollected collectable objects in level
    let collectables = new Set();

    // Keep track of milliseconds at *previous* colo(u)r cycle
    // (used for animating collectible objects)
    // Note: negative value indicates there is no previous colo(u)r
    let prev_color_cycle_ticks = -1;

    // (optional) custom colo(u)r palette
    let custom_colors = {};

    // Create top-level 'div' covering whole window
    // Note 'style.left' and 'style.right' will be
    // set when character and pixel 'div's are created
    const top_div = document.createElement( "div" );
    top_div.id = "div_id" ;
    top_div.className = "div_class";
    top_div.style.width = "100%";
    top_div.style.height = "100%";
    document.body.appendChild( top_div );

    // Set default border colo(u)r
    document.body.style.background = DEFAULT_BORDER_COL;

    // Calculate hoz/vert padding
    const PAD_LEFT
        = Math.floor( 
            ( WIDTH - CHAR_WIDTH * CHARS_WIDE ) / 2
        );
    // Note: height of one char added here to account for stat line
    const PAD_TOP
        = Math.floor( 
            ( HEIGHT - CHAR_HEIGHT * ( CHARS_HIGH - 1 ) ) / 2
        );

    console.log( "Inner window dims:", WIDTH, HEIGHT,
                 "Virtual pixel dims (in screen pixels):",
                    PIXEL_WIDTH, PIXEL_HEIGHT,
                 "Char dims (in screen pixels):",
                    CHAR_WIDTH, CHAR_HEIGHT,
                 "Active window dims (exc. stat bar):",
                    CHARS_WIDE * CHAR_WIDTH,
                    CHARS_HIGH * CHAR_HEIGHT,
                 "Active window dims (inc. stat bar):",
                    CHARS_WIDE * CHAR_WIDTH,
                    ( CHARS_HIGH + 1 ) * CHAR_HEIGHT,
                 "Padding:", PAD_LEFT, PAD_TOP );
   
    // CREATE CANVASES....

    // Main character canvas
    const CANV_CHARS = document.createElement( 'canvas' );
    CANV_CHARS.id = 'main_char_canvas';
    const TOTAL_CHAR_WIDTH 
            = CANV_CHARS.width = CHARS_WIDE * CHAR_WIDTH;
    const TOTAL_CHAR_HEIGHT 
           = CANV_CHARS.height = CHARS_HIGH * CHAR_HEIGHT;
    CANV_CHARS.style.position = "absolute";
    CANV_CHARS.style.left = PAD_LEFT + "px";
    CANV_CHARS.style.top = PAD_TOP + "px";
    top_div.appendChild( CANV_CHARS );

    // Stat bar canvas
    const CANV_SB = document.createElement( 'canvas' );
    CANV_SB.id = 'stat_bar_canvas';
    const STAT_BAR_WIDTH 
            = ( CANV_SB.width = CHARS_WIDE * CHAR_WIDTH );
    const STAT_BAR_HEIGHT 
           = ( CANV_SB.height = CHAR_HEIGHT );
    CANV_SB.style.position = "absolute";
    CANV_SB.style.left = PAD_LEFT + "px";
    CANV_SB.style.top = ( PAD_TOP - CHAR_HEIGHT ) + "px";
    top_div.appendChild( CANV_SB );

    // CREATE 2D CANVAS CONTEXTS
    const CANV_CHARS_CTX = CANV_CHARS.getContext('2d');
    const CANV_SB_CTX = CANV_SB.getContext('2d');


    // AUDIO SETTINGS
    const AUDIO_DEFAULT_GAIN = 0.05;  // Default volume when unmuted
    const AUDIO_FX_MOVE_FREQ = 100; // Player move tone, in Hz. 
    const AUDIO_FX_MOVE_DURATION = 50; // Player move tone duration in ticks 
    const AUDIO_FX_FALL_FREQ_START = 200; // Player fall tone, in Hz. 
    const AUDIO_FX_FALL_FREQ_INC = 0.75; // Ratio by which fall tone increases
    const AUDIO_FX_COLLECT_FREQ = 800; // Collect object tone, in Hz. 
    const AUDIO_FX_COLLECT_DURATION = 200; // Collect object tone duration in ticks 
    const AUDIO_FX_ALERT_FREQ = 3200; // Timer alert tone, in Hz. 
    const AUDIO_FX_ALERT_DURATION = 100; // Timer alert tone duration in ticks 
    const AUDIO_THEME_IN_GAME_GAIN = 4.0; // Relative volume of in-game theme

    // Intialize audio (see also the 'init_audio' function)
    const AUDIO = new Audio();
    
    // Audio context reference (initially set to zero)
    // This is set in 'init_audio'
    let audio_context = 0;

    // Audio oscilator references (initially set to zero)
    // These are set in 'init_audio'
    let audio_move_fx_oscillator = 0;
    let audio_collect_fx_oscillator = 0;
    let audio_theme_oscillator = 0;
    let audio_alert_fx_oscillator = 0;

    // Audio gain (volume) references (initially set to zero)
    // These are set in 'init_audio'
    let audio_master_gain = AUDIO_DEFAULT_GAIN;
    let audio_move_fx_gain = 0;
    let audio_collect_fx_gain = 0;
    let audio_theme_gain = 0;
    let audio_alert_fx_gain = 0;

    // Current callback for theme (if zero, theme is not playing)
    let audio_theme_callback = 0;

    // ASCII codes for Dr H death sequence
    const DR_H_DEATH = [ 
        32, 8, 7 , 20, 19, 9,
            8, 7 , 20, 19, 9,
            8, 7 , 20, 19, 9, 46 
        ];

    ///////////////////////////////////////////
    // GRAPHIC DATA

    // Note: This ASCII data is adapted from the MuckyVision3
    //       game engine (by the same author, also GPL3):
    //          https://github.com/MuckyTaters/MuckyVision3
    //
    // Note 2: Empty arrays here represent ASCII values not used
    //         in this game. Feel free to make use of them.

    const ASCII_DATA = [
    [],[],[],[],[],[],[], // 0 - 6  Not used
    [ // 7
    0b01001001,
    0b10010010,
    0b00100100,
    0b01001001,
    0b10010010,
    0b00100100,
    0b01001001,
    0b10010010
    ],
    [ // 8
    0b10011001,  // ALSO USED AS INVALID MARKER
    0b00110011,
    0b01100110,
    0b11001100,
    0b10011001,
    0b00110011,
    0b01100110,
    0b11001100
    ],
    [ // 9
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01000000,
    0b10000000
    ],
    [],[],[],[],[],[],  // 10 - 15   Not used      
    [ // 16
    0b11111111,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b10000001,
    0b11111111
    ],
    [],[],  // 17 - 18   Not used
    [ // 19
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000,
    0b01010101,
    0b00000000
    ],
    [ // 20
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010,
    0b01010101,
    0b10101010
    ],
    [],[],[],[],[],[],[],[],[],[],[],  // 21-31   Not used
    [ // 32
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 33
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00000000
    ],
    [ // 34
    0b00010100,
    0b00010100,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 35
    0b00010100,
    0b00010100,
    0b01111111,
    0b00010100,
    0b01111111,
    0b00010100,
    0b00010100,
    0b00000000
    ],
    [ // 36
    0b00001000,
    0b00111111,
    0b01001000,
    0b00111110,
    0b00001001,
    0b01111110,
    0b00001000,
    0b00000000
    ],
    [ // 37
    0b01110001,
    0b01010010,
    0b01110100,
    0b00001000,
    0b00010111,
    0b00100101,
    0b01000111,
    0b00000000
    ],
    [ // 38
    0b00111100,
    0b01000010,
    0b00110100,
    0b01001000,
    0b01000100,
    0b01000010,
    0b00111101,
    0b00000000
    ],
    [ // 39
    0b00011000,
    0b00001000,
    0b00010000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 40
    0b00000100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000100,
    0b00000000
    ],
    [ // 41
    0b00010000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00010000,
    0b00000000
    ],
    [ // 42
    0b00001000,
    0b01001001,
    0b00101010,
    0b00011100,
    0b00101010,
    0b01001001,
    0b00001000,
    0b00000000
    ],
    [ // 43
    0b00000000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00001000,
    0b00001000,
    0b00000000,
    0b00000000
    ],
    [ // 44
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00011000,
    0b00001000,
    0b00010000
    ],
    [ // 45
    0b00000000,
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 46
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 47
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01000000,
    0b00000000
    ],
    [ // 48
    0b00111110,
    0b01000011,
    0b01000101,
    0b01001001,
    0b01010001,
    0b01100001,
    0b00111110,
    0b00000000
    ],
    [ // 49
    0b00001000,
    0b00011000,
    0b00101000,
    0b01001000,
    0b00001000,
    0b00001000,
    0b01111111,
    0b00000000
    ],
    [ // 50
    0b00111110,
    0b01000001,
    0b00000001,
    0b00111110,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 51
    0b00111110,
    0b01000001,
    0b00000001,
    0b00011110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 52
    0b00011100,
    0b00100100,
    0b01000100,
    0b01000100,
    0b01111111,
    0b00000100,
    0b00000100,
    0b00000000
    ],
    [ // 53
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 54
    0b00111110,
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 55
    0b01111111,
    0b00000001,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 56
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 57
    0b00111110,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 58
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 59
    0b00000000,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00011000,
    0b00110000,
    0b00000000
    ],
    [ // 60
    0b00000011,
    0b00001100,
    0b00110000,
    0b01000000,
    0b00110000,
    0b00001100,
    0b00000011,
    0b00000000
    ],
    [ // 61
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00111110,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 62
    0b11000000,
    0b00110000,
    0b00001100,
    0b00000010,
    0b00001100,
    0b00110000,
    0b11000000,
    0b00000000
    ],
    [ // 63
    0b00111110,
    0b01000001,
    0b00000001,
    0b00011110,
    0b00000000,
    0b00011000,
    0b00011000,
    0b00000000
    ],
    [ // 64
    0b00111110,
    0b01000001,
    0b01011111,
    0b01010001,
    0b01011111,
    0b01000000,
    0b00111110,
    0b00000000
    ],
    [ // 65
    0b00011100,
    0b00100010,
    0b01000001,
    0b01111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 66
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b00000000
    ],
    [ // 67
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 68
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01111110,
    0b00000000
    ],
    [ // 69
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 70
    0b01111111,
    0b01000000,
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 71
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000111,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 72
    0b01000001,
    0b01000001,
    0b01000001,
    0b01111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 73
    0b01111111,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b01111111,
    0b00000000
    ],
    [ // 74
    0b01111111,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b01000100,
    0b00111000,
    0b00000000
    ],
    [ // 75
    0b01000001,
    0b01000010,
    0b01000100,
    0b01111000,
    0b01000100,
    0b01000010,
    0b01000001,
    0b00000000
    ],
    [ // 76
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01111111,
    0b00000000
    ],
    [ // 77
    0b01000001,
    0b01100011,
    0b01010101,
    0b01001001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 78
    0b01000001,
    0b01100001,
    0b01010001,
    0b01001001,
    0b01000101,
    0b01000011,
    0b01000001,
    0b00000000
    ],
    [ // 79
    0b00111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 80
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 81
    0b00111110,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01000101,
    0b01000010,
    0b00111101,
    0b00000000
    ],
    [ // 82
    0b01111110,
    0b01000001,
    0b01000001,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 83
    0b00111110,
    0b01000001,
    0b01000000,
    0b00111110,
    0b00000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 84
    0b01111111,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 85
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 86
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00000000
    ],
    [ // 87
    0b01000001,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01010101,
    0b01100011,
    0b01000001,
    0b00000000
    ],
    [ // 88
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00010100,
    0b00100010,
    0b01000001,
    0b00000000
    ],
    [ // 89
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 90
    0b01111111,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01111111,
    0b00000000
    ],
    [ // 91
    0b00011100,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00011100,
    0b00000000
    ],
    [ // 92
    0b01000000,
    0b00100000,
    0b00010000,
    0b00001000,
    0b00000100,
    0b00000010,
    0b00000001,
    0b00000000
    ],
    [ // 93
    0b00011100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00011100,
    0b00000000
    ],
    [ // 94
    0b00001000,
    0b00010100,
    0b00100010,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 95
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b01111111,
    0b00000000
    ],
    [ // 96
    0b00011000,
    0b00010000,
    0b00001000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 97
    0b00000000,
    0b00000000,
    0b00111110,
    0b00000001,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 98
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 99
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01000000,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 100
    0b00000001,
    0b00000001,
    0b00111111,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 101
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01111111,
    0b01000000,
    0b00111110,
    0b00000000
    ],
    [ // 102
    0b00001111,
    0b00010000,
    0b00010000,
    0b01111111,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00000000
    ],
    [ // 103
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 104
    0b01000000,
    0b01000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 105
    0b00001000,
    0b00000000,
    0b00111000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00000000
    ],
    [ // 106
    0b00000100,
    0b00000000,
    0b00011100,
    0b00000100,
    0b00000100,
    0b00000100,
    0b00111000,
    0b00000000
    ],
    [ // 107
    0b01000000,
    0b01000000,
    0b01000001,
    0b01000010,
    0b01111100,
    0b01000010,
    0b01000001,
    0b00000000
    ],
    [ // 108
    0b00001100,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00111110,
    0b00000000
    ],
    [ // 109
    0b00000000,
    0b00000000,
    0b01110110,
    0b01001001,
    0b01001001,
    0b01001001,
    0b01001001,
    0b00000000
    ],
    [ // 110
    0b00000000,
    0b00000000,
    0b01111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00000000
    ],
    [ // 111
    0b00000000,
    0b00000000,
    0b00111110,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111110,
    0b00000000
    ],
    [ // 112
    0b00000000,
    0b00000000,
    0b01111110,
    0b01000001,
    0b01111110,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 113
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000001,
    0b00111111,
    0b00000001,
    0b00000001,
    0b00000000
    ],
    [ // 114
    0b00000000,
    0b00000000,
    0b01011110,
    0b01100001,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000
    ],
    [ // 115
    0b00000000,
    0b00000000,
    0b00111111,
    0b01000000,
    0b00111110,
    0b00000001,
    0b01111110,
    0b00000000
    ],
    [ // 116
    0b00000000,
    0b00100000,
    0b01111110,
    0b00100000,
    0b00100000,
    0b00100010,
    0b00011100,
    0b00000000
    ],
    [ // 117
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01000001,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    [ // 118
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b00100010,
    0b00010100,
    0b00001000,
    0b00000000
    ],
    [ // 119
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01001001,
    0b01010101,
    0b00100010,
    0b00000000
    ],
    [ // 120
    0b00000000,
    0b00000000,
    0b01000001,
    0b00110110,
    0b00001000,
    0b00110110,
    0b01000001,
    0b00000000
    ],
    [ // 121
    0b00000000,
    0b00000000,
    0b01000001,
    0b01000001,
    0b01111111,
    0b00000001,
    0b00111110,
    0b00000000
    ],
    [ // 122
    0b00000000,
    0b00000000,
    0b01111111,
    0b00000010,
    0b00011100,
    0b00100000,
    0b01111111,
    0b00000000
    ],
    [ // 123
    0b00000110,
    0b00001000,
    0b00001000,
    0b00010000,
    0b00001000,
    0b00001000,
    0b00000110,
    0b00000000
    ],
    [ // 124
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 125
    0b00110000,
    0b00001000,
    0b00001000,
    0b00000100,
    0b00001000,
    0b00001000,
    0b00110000,
    0b00000000
    ],
    [ // 126
    0b00000000,
    0b00000000,
    0b00111001,
    0b01001110,
    0b00000000,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    // These are unused
    [],[],[],[],[],  // 127 - 131
    [ // 132
    0b00000000,
    0b00100010,
    0b00000000,
    0b00111101,
    0b01000011,
    0b01000001,
    0b00111111,
    0b00000000
    ],
    // These are unused
    [],[],[],[],[],[],[],  // 133 - 139
    [],[],[],[],[],[],[],[],[],[],  // 140 - 149
    [],[],[],[],[],[],[],[],[],[],  // 150 - 159
    [],[],[],[],[],[],[],[],[],[],  // 160 - 169
    [],[],[],[],[],[],[],[],[],[],  // 170 - 179
    [],[],[],[],[],[],[],[],[],[],  // 180 - 189
    [],[],[],[],[],[],[],[],[],[],  // 190 - 199
    [],[],[],[],[],[],[],[],[],[],  // 200 - 209
    [],[],  // 210 - 211
    [ // 212  Duplicate of 246
    0b11011111,
    0b11011111,
    0b11011111,
    0b00000000,
    0b11111011,
    0b11111011,
    0b11111011,
    0b00000000
    ],
    [ // 213
    0b00110000,  // Scorpion 
    0b01111000,
    0b10000100,
    0b10000000,
    0b11000000,
    0b01100111,
    0b01111100,
    0b10100111
    ],
    [ // 214
    0b00000000,  // Floor trap
    0b00010000,
    0b00111000,
    0b01010100,
    0b00010000,
    0b00010000,
    0b00010000,
    0b11111110
    ],
    [ // 215
    0b11000110,  // Fly
    0b11101110,
    0b11111110,
    0b01010100,
    0b01111100,
    0b10101010,
    0b10010010,
    0b01000100,
    ],
    [ // 216
    0b01111110,  // Roaming monster
    0b00100100,
    0b11100111,
    0b10111101,
    0b10111101,
    0b10111101,
    0b00100100,
    0b01100110
    ],
    [ // 217
    0b00001000,  // Droplet
    0b00001000,
    0b00011100,
    0b00011100,
    0b00101110,
    0b01011111,
    0b01111111,
    0b00111110
    ],
    [ // 218
    0b00000000, // Arrow (right facing)
    0b00000000,
    0b10100010,
    0b01111111,
    0b10100010,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 219
    0b00000000, // Arrow (left facing)
    0b00000000,
    0b01000101,
    0b11111110,
    0b01000101,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    [ // 220
    0b01100110,  // Bat
    0b11000011,
    0b11111111,
    0b10111101,
    0b10011001,
    0b10000001,
    0b01000010,
    0b00000000
    ],
    [ // 221
    0b00001000,
    0b00011100,
    0b00101010,
    0b01001001,
    0b00001000,
    0b00001000,
    0b00001000,
    0b00000000
    ],
    [ // 222
    0b00001000,
    0b00000100,
    0b00000010,
    0b01111111,
    0b00000010,
    0b00000100,
    0b00001000,
    0b00000000
    ],
    [ // 223
    0b00001000,
    0b00001000,
    0b00001000,
    0b01001001,
    0b00101010,
    0b00011100,
    0b00001000,
    0b00000000
    ],
    [ // 224
    0b00001000,
    0b00010000,
    0b00100000,
    0b01111111,
    0b00100000,
    0b00010000,
    0b00001000,
    0b00000000
    ],
    [ // 225
    0b01111110, // Ghost
    0b11010111,
    0b11111101,
    0b10111101,
    0b10011001,
    0b00011000,
    0b00010000,
    0b00001000
    ],
    [ // 226
    0b00000001,
    0b00000011,
    0b00000110,
    0b00001100,
    0b01011000,
    0b01110000,
    0b00100000,
    0b00000000
    ],
    [ // 227
    0b01000001,
    0b01100011,
    0b00110110,
    0b00011100,
    0b00110110,
    0b01100011,
    0b01000001,
    0b00000000
    ],
    // These are unused
    [],[],[],[],[],[],[],[],[],[],[],  // 228 - 238
    [ // 239
    0b01000010,  // Enemy 1
    0b00111100,
    0b01011010,
    0b11011011,
    0b10111101,
    0b10111101,
    0b10011001,
    0b11000011
    ],
    [ // 240
    0b00111110,  // Skull
    0b01111111,
    0b01001001,
    0b01101011,
    0b00111110,
    0b00101010,
    0b00000000,
    0b00000000
    ],
    [ // 241
    0b00111110,  // Dr H
    0b01111111,
    0b01001001,
    0b01111111,
    0b01100011,
    0b01111111,
    0b01010101,
    0b01010101
    ],
    // These are unused
    [],[],[],  // 242 - 244
    [ // 245
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010,
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010
    ],
    [ // 246
    0b11011111,
    0b11011111,
    0b11011111,
    0b00000000,
    0b11111011,
    0b11111011,
    0b11111011,
    0b00000000
    ],
    // This is unused
    [],  // 247
    [  // 248
    0b01110101,  // FX only
    0b01000101,
    0b01000111,
    0b01100010,
    0b01000111,
    0b01000101,
    0b01000101,
    0b00000000
    ],
    [ // 249
    0b00001000,  // Full audio
    0b00001100,
    0b00001110,
    0b00001010,
    0b00001000,
    0b00111000,
    0b00111000,
    0b00000000
    ],
    [ // 250
    0b10001000,  // Full mute
    0b01001100,
    0b00101110,
    0b00011010,
    0b00001000,
    0b00111100,
    0b00111010,
    0b00000001
    ],
    [ // 251
    0b01111000,  // Player image
    0b00001100,
    0b00111111,
    0b00001100,
    0b00011110,
    0b00111110,
    0b01111111,
    0b11111111
    ],
    [ // 252
    0b00000111,  // Collectable image
    0b00000101,
    0b11111101,
    0b10100101,
    0b10100111,
    0b00000000,
    0b00000000,
    0b00000000
    ],
    // These are unused
    [],[], // 253 - 254
    [ // 255
    0b00111110,
    0b01000001,
    0b01011101,
    0b01010001,
    0b01011101,
    0b01000001,
    0b00111110,
    0b00000000
    ]
    ]

    // ASCII data quality check
    if( ASCII_DATA.length !== 256 )
    {
        console.log( "Fundamental ERROR: ASCII_DATA has length",
                     ASCII_DATA.length,
                     ", should be 256." );
        return;

    }
    for( let n = 0; n < 256; n++ )
    {
        if( typeof ASCII_DATA[n] == "undefined" )
        {
            console.log( "Fundamental ERROR: graphic data for",
                         "ASCII code", n, "is 'undefined', it",
                         "should be either an empty array '[]' or",
                         "an array of length 8." );
            return;
        }
        const NUM_ROWS = ASCII_DATA[n].length;
        if( NUM_ROWS == 0 ) { continue; }
        if( NUM_ROWS !== 8 )
        {
            console.log( "Fundamental ERROR: graphic data for",
                         "ASCII code", n, "has", NUM_ROWS,
                         "row(s), should be zero or 8." );
            return;
        }
        for( let m = 0; m < 8; m++ )
        {
            const VAL = ASCII_DATA[n];
            if( VAL < 0 || VAL > 255 )
            {
                console.log( "Fundamental ERROR: row", m,
                             "of graphic data for ASCII code", n,
                             "has out-of-range value", VAL,
                             ", should be in range 0-255." );
                return;
            }
        }
    }
    console.log( "ASCII graphic data integrity check passed." );

    // Super secret numbers!
    const SPEC = [10532,20726,16569,24644,19588,7461,15143,14097,11526];

    // Title screen bitmap
    const TITLE_SCREEN_BITMAP_DATA = [
    0x1f203c00,0x7e600fff,0x00000000,0x00000000,0x00000000,0x00000000, // 0
    0x07e0f800,0xbb801ff8,0x00000000,0x00000000,0x00000000,0x00000000, // 1
    0x01e0b001,0xf0007e00,0x00000000,0x00000000,0x00000000,0x00000000, // 2
    0x03a1e003,0x8000fc00,0x00000000,0x00000000,0x00000000,0x00000000, // 3
    0x02e34007,0x0001e000,0x00000000,0x00000000,0x00000000,0x00000000, // 4
    0x03c2c00e,0x0003c000,0x00000000,0x00000000,0x00000000,0x00000000, // 5
    0x0782801e,0x003f8000,0x00000000,0x00000000,0x00000000,0x00000000, // 6
    0x05c38014,0x00270000,0x00000000,0x00000000,0x00000000,0x00000000, // 7
    0x0743803c,0x007c0000,0x00000000,0x00000000,0x00800000,0x00000000, // 8
    0x06230070,0x00f80000,0x00000000,0x00000000,0x00800000,0x00000000, // 9
    0x03e300c0,0x1fe00000,0x00000000,0x00000000,0x00800000,0x00000000, // 10
    0x00c300c0,0x71800000,0x00000000,0x00000000,0x00800000,0x00000000, // 11
    0x00610080,0x4f000000,0x00000000,0x00000000,0x00c00000,0x00000000, // 12
    0x00610180,0xf8000000,0x00000000,0x00000000,0x00c00000,0x00000000, // 13
    0x00410181,0xe0000000,0x00000000,0x00000000,0x00e00000,0x00000000, // 14
    0x00410301,0xe0000000,0x00000000,0x01e00000,0x00e00000,0x00000000, // 15
    0x00410e0f,0xc0000000,0x0001f800,0x03f00000,0x01e1f000,0x00000000, // 16
    0x0041080e,0x00000000,0x000ffc00,0x03f80000,0x01e7fc00,0x00000000, // 17
    0x00600808,0x04000000,0x000ffe00,0x07fc0000,0x03e7ff03,0x80000000, // 18
    0x00300808,0x00000000,0x001fff00,0x07ff0000,0x03e7ff80,0xe7000000, // 19
    0x00100818,0x00000000,0x003fff80,0x0f1fc000,0x03e7ffc0,0x3c000000, // 20
    0x001840f0,0x00000000,0x007fdfe0,0x1fdfe000,0x03e7ffc0,0x18000000, // 21
    0x08100080,0x00000000,0x007f9fe0,0x3fcff000,0x03e7f8e0,0x18000000, // 22
    0x00000000,0x01000000,0x00ff3ff0,0x3fe3f000,0x03e7f3e0,0x00000000, // 23
    0x00000420,0x80000000,0x01fe7df0,0x7ef9f800,0x03e627f0,0x00000000, // 24
    0x00020070,0x00000000,0x03f8f1f8,0x7e7c7800,0x03e78ff0,0x00000000, // 25
    0x00300078,0x00000000,0x07f9f7f8,0x7f3c3800,0x03e7cff0,0x00000000, // 26
    0x007e03e4,0x00000000,0x07f1f7fc,0x7f9c3800,0x03e7cff8,0x00000000, // 27
    0x00bfe27e,0x00000000,0x0fe1e7fc,0xe3cc1800,0x03e7fff8,0x00000000, // 28
    0x01ffffff,0x00000000,0x07c1e7fe,0xe0c40800,0x03e3fff8,0x00000001, // 29
    0x03d779ff,0x00000000,0x07c1e7ff,0xf0c40800,0x03f3fff8,0x00000003, // 30
    0x07ffffff,0x80000000,0x0701c7ff,0xf0c00000,0x03f3fff8,0x00000003, // 31
    0x0eefffff,0xc0000000,0x0601870c,0x90400000,0x07f1fff8,0x1c180007, // 32
    0x0fffffef,0x70000000,0x0401860e,0xb8000000,0x07f9fff8,0x0630000f, // 33
    0x0fffffff,0xf0000000,0x0401040f,0xf8000000,0x07f9fff8,0x03e0000f, // 34
    0x1f7dffff,0xf8000000,0x0401040f,0xf8000200,0x07f8fff8,0x00c0000f, // 35
    0x7bffffff,0xf8000000,0x04000007,0xf0000600,0x07fcfff0,0x00c0001f, // 36
    0x3f7fffff,0xfc000000,0x04000001,0x10000700,0x1ffe3ff0,0x0000003f, // 37
    0xfffffffb,0xfc000000,0x00000001,0x10000700,0x0c031ff0,0x0000003f, // 38
    0xfdeffffb,0xfe000000,0x00000001,0x10000700,0x39181fe0,0x0000007d, // 39
    0xb7ffff39,0xfe000000,0x00000000,0x10000700,0x031c3fe0,0x0000007f, // 40
    0xe7bff5c9,0xff000000,0x00000000,0x00000700,0x071cffc0,0x0000007f, // 41
    0x27ffff18,0x7f000000,0x00000000,0x00000780,0x071cffc0,0x000000ff, // 42
    0x07df3a0a,0xbf800000,0x00000000,0x00000780,0x071cff80,0x000000ef, // 43
    0x5073ea28,0x1f802000,0x00000000,0x00000380,0x071cff00,0x000001ff, // 44
    0xf8620e08,0x1dc02000,0x00000000,0x00000780,0x07fcfc00,0x000001ff, // 45
    0xfc20000c,0x07c07000,0x00000000,0x00000780,0x07fcf000,0x000003ff, // 46
    0xfc001005,0x03e07000,0x00000000,0x00000780,0x07f80000,0x000003ff, // 47
    0xfc010001,0x01f0f800,0x00000000,0x00000780,0x07f00000,0x000007ff, // 48
    0xfd830081,0x803cd800,0x00000000,0x00000f80,0x07c40000,0x04000f7f, // 49
    0xff838081,0xc93df800,0x00000000,0x00000f80,0x079e0000,0x0e000fff, // 50
    0xffc38083,0xc001fc00,0x00000000,0x00001f80,0x077e0000,0x1f001fff, // 51
    0xdfc7c1c3,0xe061fc00,0x00000000,0x00001f80,0x067f0000,0x1f001ffd, // 52
    0xffe7c1c3,0xe003dc10,0x00000000,0x00003fc0,0x00ff8000,0x3f803fff, // 53
    0xffffc3e3,0xf007fa10,0x00000000,0x00003fc0,0x03ff8000,0x3fc03fff, // 54
    0xffffe7e7,0xf01ffe18,0x00000000,0x00007fe0,0x07ff8000,0x3fc07f77, // 55
    0xfffffffe,0xffffbe38,0x00000000,0x0001fff0,0x0fffc000,0x7fe0ffff, // 56
    0xffffffff,0xffffff38,0x00000000,0x00004000,0x0fffc000,0x7ff0ffff, // 57
    0xfffdffff,0xfff3fb3c,0x00000000,0x00001cc0,0x1fffc000,0xfff9ff0d, // 58
    0xfffdffff,0xffffff7c,0x00000000,0x00001cc0,0x3fffe000,0xfbfffc7f, // 59
    0xffffffff,0xffffffec,0x20000000,0x00001cc0,0x3ffff001,0xfdfffcf7, // 60
    0xfdffffff,0xfffffffc,0x20000000,0x00001cc0,0x7ffff001,0xfffff9c7, // 61
    0xf9ffffff,0xfffffffc,0x30000000,0x00001fc0,0x7ffff803,0xffbfeb63, // 62
    0xf9ffffff,0xfffffefc,0x30000000,0x00001fc0,0x601ff807,0xfffbfa3b, // 63
    0xf9ffffff,0xfffffffc,0x30000000,0x00001fc0,0xe7c7f807,0xf7ff7e0b, // 64
    0xf1ffffff,0xdffffff6,0x70000000,0x00001fc1,0xcff3fc0f,0xffffdc0f, // 65
    0xc0f7ffff,0xfffdfffe,0x58200000,0x00001f87,0x9ff9ff8f,0x7df59901, // 66
    0x80f7ff7f,0xffffffff,0x78200000,0x00001f82,0x1ffc011f,0x7d172801, // 67
    0x00f3fe7f,0xffffffdf,0xf8200000,0x00001f80,0x7e7df01e,0x2d172800, // 68
    0x00e1fc7f,0xfffffffb,0xf8200000,0x00001f80,0xfe7d503e,0x2f166810, // 69
    0x0060f83f,0xffffffff,0xf4600000,0x00001f80,0xfc3df03d,0xfb1ffa20, // 70
    0x2000f83f,0xbfffffff,0xbc700000,0x00001f80,0xfc3d707d,0x1a0ec000, // 71
    0x0000301f,0xbfffffff,0xfcf00000,0x00001faa,0xfc3de079,0x1e0e8420, // 72
    0x0400000f,0x9fffbfff,0xfe700000,0x00001fbe,0xfc3db0ff,0x161e8010, // 73
    0x0000000f,0x9fffffff,0xfff00000,0x00001fbe,0xfc3df1f8,0x1c0f8000, // 74
    0x00000087,0x1fffffff,0xfff00000,0x00001fbe,0xfc3df1f2,0x18070008, // 75
    0x00000003,0x0fffffff,0xdbf80000,0x00001fbe,0xfc3d57f6,0x00070000, // 76
    0x00000001,0x0fffffff,0xfff80000,0x00001fbe,0xfe3df7e1,0x00070200, // 77
    0x0010ffe0,0x07ffffff,0xffe80000,0x00001fbe,0xfffde7d0,0x30800000, // 78
    0x2001fff0,0x07f7ffff,0xff7c0000,0x00001fbf,0xfffd8f48,0x00040400, // 79
    0x0003fff8,0x07f7ffff,0xfff70000,0x00001fff,0xfffc3dd2,0x0800801e, // 80
    0x000ffffc,0x03e7ffff,0xfff70000,0x00001fc1,0xfffd3c40,0x00000010, // 81
    0x000ffffc,0x01e3efff,0xffffc000,0x00001fdd,0xfffe7c08,0x00200030, // 82
    0x001ffffe,0x0043efff,0xffffe000,0x00001f9c,0xfffce500,0x2003fe60, // 83
    0x0033ff8e,0x0001efff,0xfffff000,0x00001fb6,0xfff9fc88,0x01020340, // 84
    0x00387e3f,0x2001e7ff,0xfe6cfc00,0x00001fb6,0xfff34400,0x000601c0, // 85
    0x003c183f,0x0001c7f7,0xee603700,0x00005fb6,0xffe25e08,0x7f8400c0, // 86
    0x003f18ff,0x000083f7,0xe6001f80,0x0000dfb6,0xffcc7900,0xc07c3880, // 87
    0x003fffff,0x080003e7,0xc60071c0,0x0001dfb6,0xff3e9841,0x801c3840, // 88
    0x003fffff,0x000001e3,0x827811f8,0x0003dfbe,0xfe7d1201,0x0008fe40, // 89
    0x4038ffff,0x000000c3,0x822000e8,0x0003dfbe,0xfcff2001,0x000cfe60, // 90
    0x003e000f,0x00004003,0x0303c47c,0xc07e5fbe,0xe1fb43e3,0x3ae4fe20, // 91
    0x007f9e7f,0x00000001,0x0180001f,0x61fc1f00,0x0fd105fe,0x2aa43820, // 92
    0x00ff9e7f,0x00080000,0x00e03c07,0xff1c3e00,0x3fd49f06,0x32e43820, // 93
    0x00ff9e7f,0x00000000,0x00fe201b,0x87007ffc,0x7ff23c03,0x2a843820, // 94
    0x00ffbf7f,0x80000040,0x007c3c00,0x0181fc00,0xfbd67801,0x2a863820, // 95
    0x00ffbf7f,0x80000000,0x003e00e0,0x0007f801,0xff10f001,0x00023820, // 96
    0x00ffffff,0xc0800000,0x401ae180,0xf00fffe3,0xeff1e001,0x80023820, // 97
    0x00ffffff,0xc0000000,0x000e011c,0x807fe007,0xf9c1c000,0x80020020, // 98
    0x00ffffff,0xc0002020,0x000780f0,0xe3ffc00f,0xfda98000,0xc0030020, // 99
    0x01ffffff,0xc0000000,0x0003f0a0,0x03fffc1f,0xcd938000,0x40010020, // 100
    0x01ffffff,0xc0000000,0x00007800,0x7ff8003f,0xbdef0000,0x40010020, // 101
    ];

    // END OF GRAPHIC DATA
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // AUDIO DATA

    const AUDIO_EVIL_LAUGH = "data:audio/mp3;base64,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";

    // Note id/duration data for end-of-level fanfare 
    // Note: Note ID 57 is 'tuning A', i.e. 440Hz.
    const AUDIO_FX_FANFARE_DATA = [
        [ 67, 400 ],
        [  0, 50 ],
        [ 65, 100 ],
        [  0, 50 ],
        [ 71, 400 ],
        [  0, 50 ],
        [ 69, 100 ],
        [  0, 50 ],
        [ 75, 800 ]
    ];

    // Note id/duration data for intro theme
    // Note: Note ID 57 is 'tuning A', i.e. 440Hz.
    // Adapted from "In the Hall of the Mountain King"
    // by Edvard Greig, 1875.
    const AUDIO_THEME_DATA = [
        [ 45, 400 ],  // A -1
        [ 47, 400 ],  // B -1
        [ 48, 400 ],  // C  0
        [ 50, 400 ],  // D  0
        [  0, 25 ],
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [  0, 25 ],
        [ 52, 800 ],  // E  0
        [  0, 25 ],
        [ 51, 400 ],  // Eb 0
        [ 47, 400 ],  // B -1
        [  0, 025 ], 
        [ 51, 800 ],  // Eb 0
        [  0, 25 ],
        [ 50, 400 ],  // D  0
        [ 46, 400 ],  // Bb -1
        [  0, 025 ], 
        [ 50, 800 ],  // D  0
        [  0, 025 ], 
        [ 45, 400 ],  // A -1
        [ 47, 400 ],  // B -1
        [ 48, 400 ],  // C  0
        [ 50, 400 ],  // D  0
        [  0, 25 ],
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [ 52, 400 ],  // E  0
        [ 57, 400 ],  // A  0
        [  0, 25 ],
        [ 55, 400 ],  // G  0
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [ 52, 400 ],  // E  0
        [  0, 25 ],
        [ 55, 1600 ],  // G  0
        [  0, 25 ],
        [ 45, 400 ],  // A -1
        [ 47, 400 ],  // B -1
        [ 48, 400 ],  // C  0
        [ 50, 400 ],  // D  0
        [  0, 25 ],
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [  0, 25 ],
        [ 52, 800 ],  // E  0
        [  0, 25 ],
        [ 51, 400 ],  // Eb 0
        [ 47, 400 ],  // B -1
        [  0, 025 ], 
        [ 51, 800 ],  // Eb 0
        [  0, 25 ],
        [ 50, 400 ],  // D  0
        [ 46, 400 ],  // Bb -1
        [  0, 025 ], 
        [ 50, 800 ],  // D  0
        [  0, 025 ], 
        [ 45, 400 ],  // A -1
        [ 47, 400 ],  // B -1
        [ 48, 400 ],  // C  0
        [ 50, 400 ],  // D  0
        [  0, 25 ],
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [ 52, 400 ],  // E  0
        [ 57, 400 ],  // A  0
        [  0, 25 ],
        [ 55, 400 ],  // G  0
        [ 52, 400 ],  // E  0
        [ 48, 400 ],  // C  0
        [ 52, 400 ],  // E  0
        [  0, 25 ],
        [ 55, 1600 ],  // G  0
        [  0, 25 ],
        [ 52, 400 ],  // E  0  ******
        [ 54, 400 ],  // F# 0
        [ 56, 400 ],  // Ab 0
        [ 57, 400 ],  // A  0
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 25 ],
        [ 60, 400 ],  // C  1
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 60, 800 ],  // C  1
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 025 ], 
        [ 52, 400 ],  // E  0
        [ 54, 400 ],  // F# 0
        [ 56, 400 ],  // Ab 0
        [ 57, 400 ],  // A  0
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 25 ],
        [ 60, 400 ],  // C  1
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 60, 800 ],  // C  1
        [  0, 025 ], 
        [ 59, 1600 ],  // B  1
        [ 52, 400 ],  // E  0
        [ 54, 400 ],  // F# 0
        [ 56, 400 ],  // Ab 0
        [ 57, 400 ],  // A  0
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 25 ],
        [ 60, 400 ],  // C  1
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 60, 800 ],  // C  1
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 025 ], 
        [ 52, 400 ],  // E  0
        [ 54, 400 ],  // F# 0
        [ 56, 400 ],  // Ab 0
        [ 57, 400 ],  // A  0
        [  0, 025 ], 
        [ 59, 400 ],  // B  0
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 59, 800 ],  // B  0
        [  0, 25 ],
        [ 60, 400 ],  // C  1
        [ 56, 400 ],  // Ab 0
        [  0, 025 ], 
        [ 60, 800 ],  // C  1
        [  0, 025 ], 
        [ 59, 1600 ],  // B  1
        [  0, 025 ] 
    ];
    
    // END OF AUDIO DATA
    ///////////////////////////////////////////

    ///////////////////////////////////////////
    // LEVEL DESIGN

    // This must match the size of the following arrays:
    //  LEVEL_DATA, LEVEL_TIMINGS, LEVEL_PALETTE, LEVEL_INTRO_TEXT
    const NUM_LEVELS = 10;

    // Declare ASCII codes displayed on screen
    // for various level components
    const LEVEL_ERROR = 7;  // Indicates unrecognised symbol in level map
    const LEVEL_SPACE = 32;
    const LEVEL_BRICK = 246;
    const LEVEL_HOLLOW_BRICK = 16;
    const LEVEL_FAKE_BRICK = 212;
    const LEVEL_LADDER = 245;
    const LEVEL_SKULL = 240;
    const LEVEL_SPIKE = 227;
    const LEVEL_COLLECTABLE = 252;

    // List of colo(u)rs through which to cycle when drawing
    // collectable items
    const LEVEL_COLLECTABLE_COLOR_CYCLE
        = ['yellow','orange','red','purple','blue','cyan','green'];
   
    // Declare number of enemy types (excluding Dr H)
    const NUM_ENEMY_TYPES = 13;

    // This dictionary connects the symbols (used to represent
    // enemies in level maps) to the sprite type,
    // e.g. '@' represents a Type 1 enemy sprite, and so on.
    // IMPORTANT: This should have one key for each enemy type
    const ENEMY_LEVEL_NOTATION = {
        '@':1,  // Basic monster
        '^':2,  // Bat
        '':3,  // Left moving arrow
        '~':4,  // Right moving arrow
        'g':5,  // Ghost
        'd':6,  // Acid drop
        'r':7,  // Roaming monster
        'f':8,  // Fly
        'e':9,  // Fly (faster moving)
        'w':10, // Floor trap
        'v':11, // Floor trap (faster moving)
        's':12, // Scorpion
        'o':13  // Doppleganger
    };

    // Enemy colo(u)r definitions
    const ENEMY_COL = [
        'Blue',
        'Magenta',
        'LightBlue',
        'LightBlue',
        'White',
        'Green',
        '#DAA520', // 'GoldenRod',
        'LightGray',
        'White',
        'Red',
        'Red',
        'Purple',
        'Orange'
    ];

    // Enemy sprite ascii image
    ENEMY_SPRITE_ASCII = [ 239, 220, 219, 218, 225, 217, 216, 215, 215, 214, 214, 213, PLAYER_CHAR_ASCII ];

    // Enemy start direction
    ENEMY_START_DIR = [
        DIR_RIGHT,
        DIR_UP,
        DIR_LEFT,
        DIR_RIGHT,
        DIR_NONE,
        DIR_NONE,
        DIR_LEFT,
        DIR_NONE,
        DIR_NONE,
        DIR_NONE,
        DIR_NONE,
        DIR_LEFT,
        DIR_RIGHT
    ];

    // Enemy ticks per move (i.e. inverse of speed)
    ENEMY_TICKS_PER_MOVE = [ 330, 250, 200, 200, 400, 200, 450, 1500, 1000, 2000, 800, 250, 450 ];

    // Enemy returns to start pos when player loses life
    ENEMY_POS_RESET = [ false, true, true, true, true, true, true, false, false, true, true, true, true ];

    // Quality check
    if( NUM_ENEMY_TYPES !== ENEMY_COL.length
        || NUM_ENEMY_TYPES !== ENEMY_SPRITE_ASCII.length
        || NUM_ENEMY_TYPES !== ENEMY_START_DIR.length
        || NUM_ENEMY_TYPES !== ENEMY_TICKS_PER_MOVE.length
        || NUM_ENEMY_TYPES !== ENEMY_POS_RESET.length
    )
    {
        console.log( "Error: length of ENEMY_COL (",
                     ENEMY_COL.length,
                     "), ENEMY_SPRITE_ASCII (",
                     ENEMY_SPRITE_ASCII.length,
                     "), ENEMY_START_DIR (",
                     ENEMY_START_DIR.length,
                     "), ENEMY_POS_RESET (",
                     ENEMY_POS_RESET.length,
                     ") and/or ENEMY_TICKS_PER_MOVE (",
                     ENEMY_TICKS_PER_MOVE.length,
                     ") vectors do not match NUM_ENEMY_TYPES (",
                     NUM_ENEMY_TYPES, ")",
        );
        return;
    }

    // Additional sprite types
    const SPRITE_TYPE_PLAYER = 0;
    const SPRITE_TYPE_DR_H = NUM_ENEMY_TYPES + 1;
 
    // Declare actual ASCII codes represented
    // by the symbols used in the level maps below
    // e.g. '.' maps to blank space (ASCII 32)
    let LEVEL_NOTATION = {};
    {

        LEVEL_NOTATION["UNKNOWN"] = LEVEL_ERROR; 
        LEVEL_NOTATION['.'] = LEVEL_SPACE;
        LEVEL_NOTATION['='] = LEVEL_BRICK;
        LEVEL_NOTATION['*'] = LEVEL_HOLLOW_BRICK;
        LEVEL_NOTATION['%'] = LEVEL_FAKE_BRICK;
        LEVEL_NOTATION['#'] = LEVEL_LADDER;
        LEVEL_NOTATION['&'] = LEVEL_SKULL;
        LEVEL_NOTATION['|'] = LEVEL_SPIKE;
        LEVEL_NOTATION['c'] = LEVEL_COLLECTABLE;

        // These symbols have special meaning, but display as space
        LEVEL_NOTATION['p'] = LEVEL_SPACE; // Player sprite start
        LEVEL_NOTATION['k'] = LEVEL_SPACE; // Player checkpoint
        
        // This symbols has special meaning, but displays as ladder
        LEVEL_NOTATION['j'] = LEVEL_LADDER; // Player ladder checkpoint
        
        // Add enemy symbols to LEVEL_NOTATION. Note a 'space'
        // is used to draw the character square when the level
        // is rendered, as enemies are instead rendered using
        // sprites.
        for( const key in ENEMY_LEVEL_NOTATION )
        {
            LEVEL_NOTATION[key] = LEVEL_SPACE; 
        }
    }

    // Identify which symbols are solid and in what way
    // (ammend this to suit)
    let LEVEL_SOLID_ASCII_VALUES = {};
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_BRICK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_HOLLOW_BRICK ] = SOLID_ALL;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_FAKE_BRICK ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_LADDER ] = SOLID_TOP;
    LEVEL_SOLID_ASCII_VALUES [ LEVEL_SKULL ] = SOLID_TOP;

    // Identify which symbols are deadly to player
    let LEVEL_DEADLY_ASCII_VALUES = new Set();
    LEVEL_DEADLY_ASCII_VALUES.add( LEVEL_SKULL ); 
    LEVEL_DEADLY_ASCII_VALUES.add( LEVEL_SPIKE ); 

    // Declare level maps
    // These MUST match dimensions CHARS_WIDE and CHARS_HIGH 
    const LEVEL_DATA = [
    [  // Level 1
        "........................",
        ".............^..........",
        ".c.k.w.k.....c...k.&.kc.",
        "=====*====#=============",
        "..........#.............",
        "....c..k..#........k....",
        "....===#..#...@....=..c.",
        "=......========#========",
        "==.............#........",
        "===............#........",
        "====......c@...#.c......",
        "=====.....==========#===",
        "....=...............#...",
        "....=e..............#...",
        ".p..........c......k#.c.",
        "==COLLECT ALL THE KEYS!="
    ],[  // Level 2
        "..c.=.............=.....",
        "..k.=.......k.....=.k...",
        "..#.@.c.....#.....@.&.c.",
        "==#=========#===========",
        "=.d..====~..#........c..",
        "=.....c.....#.....c..&.",
        "=.c.k====k..#.kw.k&=====",
        "===#========#==*========",
        "===#=====...#......=....",
        "=..#..c.....#....ef=....",
        "=p.#=====...#.k&k...k.c.",
        "===#========#===========",
        "=c.#..c==...#...........",
        "===#=====...#....=......",
        "=c.#..c==...#...===.c.c.",
        "===ALL JOLLY GOOD FUN==="
    ],[  // Level 3
        "========================",
        ".....c..r....c.....c..@.",
        "==#============#========",
        "..#........c...#....c...",
        "========#===============",
        "....c...#........c..r..",
        "==#===================#=",
        "..#..r.c....c......c..#.",
        "===============#========",
        ".p.........c...#...r....",
        "========#=============#=",
        "....c...#....c.....c..#.",
        "==#============#========",
        "~.#.....c......#......c.",
        "========================",
        "=ROBOTS ON THE RAMPAGE!=",
    ],[  // Level 4
        "........................",
        "........c..k............",
        ".......====#..c.@..c....",
        "......=====#=========#==",
        ".....c=====.==.......#..",
        ".....======..........#..",
        "....c====@...c.......#.c",
        "....==========..k#======",
        "...k====........#.......",
        "...===....k....#........",
        "..c@.=....&.c.#...@.....",
        "..====...&===========#==",
        ".c===...&............#..",
        ".==....&.............#..",
        ".p..c.=.@...c.....c=k#..",
        "==ALL ABOUT THE TIMING=="
    ],[  // Level 5
        "=...k.k............k...=",
        "=~c.&.&.c...c......&.c.=",
        "=.===#===...=.....&===.=",
        "=....#....k===k..&.....=",
        "=kc..#...v=====w&....ck=",
        "===..#...*=====*..=#====",
        "=....#....=&&&=....#...=",
        "=....#....=&g&=....#...=",
        "=p.k.#.ck.=&&&=..c.#...=",
        "===#=================#==",
        "=..#......=ddd=......#.=",
        "=..#.................#.=",
        "=c.#k&kck&k...k&kck&k#.=",
        "============#===========",
        "=.c....s.c..#..c..s..c.=",
        "======THE MAUSOLEUM====="
    ],[  // Level 6
        "========================",
        "=~c####c#o####c###c##c#=",
        "====#=====#====#=#====#=",
        "=#c#####c=#=c###=###c===",
        "=#====#===#=#==#=#=#==#=",
        "=#=c###o###c##=====#oc#=",
        "=#==#=====#==#=f=e=#====",
        "=#c####c#=#==###c###c##=",
        "====#===#=##=#========#=",
        "=p####c=#==#=#c#o###c##=",
        "=#======##c#=#=#==#===#=",
        "=###c##c##=#=#=#=c##c=#=",
        "===#=====#=#=#=#======#=",
        "=c####c#o###c###c###c#=",
        "========================",
        "===THIS IS JUST WEIRD===",
    ],[  // Level 7
        "========================",
        "========================",
        "========================",
        "======......k......=====",
        "====.......w#w.......===",
        "====......w*#*w......===",
        "===......w*=#=*w......==",
        "===.....w*==#==*wc....==",
        "===....w*===#===*w....==",
        "==....w*==...====*w....=",
        "p.....*===.kc=====*w...=",
        "==========.#.======*w..=",
        "====c......#========*.c=",
        "===========#..r.....k#==",
        "========================",
        "WHO LEFT A PYRAMID HERE?"
    ],[  // Level 8
        "........................",
        "........w..............",
        "..=k=.=k*~............c.",
        "..===#===.......=k=.=k=.",
        "...==#d=........===j===.",
        "...=j.=.........==#d=..",
        "...===j=~........==#.=..",
        "....=#=c=c=c=c=c===j=..",
        "...===#=#=#=#=#=#==d#=..",
        "...===#.#r#.#.#.j==.#=..",
        "...===#===#===#====j==..",
        "...===#.k.#.k.#k.==#d=..",
        ".c.===#r&c#.&@#&c==#.=..",
        "...===#=============j=..",
        "...===#.c=====r....p#=..",
        "=====THE.BATTLEMENTS===="
    ],[  // Level 9
        "........................",
        "....k...................",
        "....======k.............",
        ".......=====%...........",
        "........k...%==...k.....",
        "........===%%====%=.....",
        "............=%c=........",
        "............=%==........",
        "............=%==........",
        "..........==%%%=%=......",
        ".........==%==%=%=......",
        "........%%%%%=%=%==.....",
        ".......==%=%==%%%%=.....",
        ".p...%%%===%====%==.....",
        "===%==%=%%%%%%==%%%=%%==",
        "===%=HERO=%WORSHIP%=%===",
    ],[  // Level 10
        "============p===========",
        "........................",
        "........................",
        "=#===#============#===#=",
        ".#.f=#............#=.e#.",
        ".#..=#.w........v.#=..#.",
        "===#===*=#=..=#=*===#===",
        "...#....e#....#e....#...",
        "..v#.....#.@..#.....#w..",
        "=#*==#.==========.#==*#=",
        ".#e..#...=....=...#..f#.",
        ".#...#v.=EXIT=~.v#...#.",
        "===#.=*#==....==#*=.#===",
        "...#...#.=....=.#...#...",
        "~..#...#...cc...#...#..",
        "====THIS IS THE END!====",
    ]
    ];

    // Declare time permitted to complete each level (in secs)
    const LEVEL_TIMINGS = [
        60,  // Level 1
        100,  // Level 2
        70,  // Level 3
        80,  // Level 4
        120,  // Level 5
        80,  // Level 6
        60,  // Level 7
        240,  // Level 8
        90,  // Level 9
        6  // Level 10
    ];

    // Declare custom colo(u)r palette for each level
    const LEVEL_PALETTE = [
        // Level 1
        {
          '#':['cyan'],
          '=':['DarkBlue','HotPink'],
          '*':['DarkBlue','black'],
          '&':['green']
        },
        // Level 2
        {
          '#':['purple'],
          '=':['#004000','Green'],
          '*':['#004000','black'],
          '&':['blue']
        },
        // Level 3
        {
          '#':['HotPink'],
          '=':['#600000','FireBrick']
        },
        // Level 4
        {
          '#':['red'],
          '=':['DarkGreen','LimeGreen'],
          '&':['blue']
        },
        // Level 5
        {
          '#':['gray'],
          '=':['#202020','Gray'],
          '*':['#202020','black'],
          '&':['AntiqueWhite']
        },
        // Level 6
        {
          /*
          'background':['DarkCyan'],
          '#':['DarkCyan','DarkCyan'],
          '=':['Orange','FireBrick']
          */
          '#':['Black','Black'],
          '=':['DarkSlateGray','DarkSeaGreen']
        },
        // Level 7
        {
          '#':['purple'],
          '=':['#004000','Green'],
          '*':['#004000','black'],
          '&':['blue']
        },
        // Level 8
        {
          '#':['cyan'],
          'j':['cyan'],
          '=':['#202060','Gray'],
          '%':['black','black'],
          '*':['#202060','black'],
          '&':['green']
        },
        // Level 9
        {
          'alpha':['orange','black'],
          '=':['white','white'],
          '%':['white','white']
        },
        // Level 10
        {
          //'alpha':['red','LightGray'],
          '=':['FireBrick','LightGray'],
          '*':['red','black'],
          '#':['cyan','black'],
          '&':['green']
        }
    ];

    const LEVEL_INTRO_TEXT = [
        // Level 1
        [  "Collect all keys.",
           "Avoid monsters & traps.",
           "Climb over obstacles",
           "using " + CHAR_UP + " then " + CHAR_LEFT 
                + " or " + CHAR_RIGHT,
           "Climb onto the skull,",
           "don't walk into it!",
           "Mind the timer!"
        ],
        // Level 2
        [  "Move fast when you can,",
           "but sometimes you must",
           "be patient.",
           "Become proficient at",
           "climbing onto",
           "obstacles and skulls."
        ],
        // Level 3
        [ "This is a speed run.",
          "",
          "Avoid the golden",
          "robots, they move",
          "randomly and can",
          "climb ladders."
        ],
        // Level 4
        [ "Learn to climb well.",
          "Time your drops",
          "with care."
        ],
        // Level 5
        [ "Now things get serious.",
          "Time your moves, but",
          "keep moving or the",
          "ghost catches you.",
          "You must sacrifice one",
          "life to the scorpions!"
        ],
        // Level 6
        [ "Those who meet their",
          "Doppleg" + String.fromCharCode( 132 ) + "nger",
          "are doomed to die.",
          "Avoid them all!",
          "",
          "And what has happened",
          "to gravity ???"
        ],
        // Level 7 
        [ "Learned to climb well?",
          "Now climb as fast as",
          "you can!",
          "",
          "Try using both hands",
          "on the keys."
        ],
        // Level 8
        [ "No respite here, get",
          "moving straight away.",
          "Be v.fast passing acid.",
          "Make the long drop last",
          "and look for patterns",
          "in the arrows so you",
          "know when to jump."
        ],
        // Level 9
        [ "Not all bricks",
          "are solid.",
          "This level contains",
          "many secrets.",
          "Find the route",
          "to the key!"
        ],
        // Level 10
        [ "Freedom is in sight!",
          "But can you outrun",
          "Dr. Horrible?"
        ],
    ];

    // Completion of the following levels
    // grants the player an extra bonus
    // life
    // Note: these internal level numbers 
    //       start at 0, so e.g. to grant
    //       an extra bonus life for Level 5,
    //       add the number 4 to this set.
    levels_with_extra_bonus_life = new Set();
    levels_with_extra_bonus_life.add( 4 );
    levels_with_extra_bonus_life.add( 7 );

    // Quality check
    if( NUM_LEVELS !== LEVEL_DATA.length
        || NUM_LEVELS !== LEVEL_TIMINGS.length
        || NUM_LEVELS !== LEVEL_PALETTE.length
        || NUM_LEVELS !== LEVEL_INTRO_TEXT.length
    )
    {
        console.log( "Error: size of LEVEL_DATA (",
                     LEVEL_DATA.length,
                     "), LEVEL_TIMINGS (", LEVEL_TIMINGS.length,
                     "), LEVEL_PALETTE (", LEVEL_PALETTE.length,
                     ") and LEVEL_INTRO_TEXT (",
                     LEVEL_INTRO_TEXT.length,
                     ") do match NUM_LEVELS (", NUM_LEVELS, ")" );
        return;
    }

    // END OF LEVEL DATA
    ///////////////////////////////////////////


    ///////////////////////////////////////////
    // FUNCTION DEFS

    //! Player loses life
    player_loses_life = function( level_restart = false )
    {
        // Cancel any playing sound FX
        cancel_audio_FX();
        
        // Play losing FX
        if( audio_mute !== MUTE_STATUS_MUTE_ALL )
        {
            AUDIO.src = AUDIO_EVIL_LAUGH;
            AUDIO.play();
        }

        console.log( "Player loses life" );

        // Stop keyboard event handling
        document.removeEventListener( 'keydown', handleKeyEvent );
        key_handler_on = false;

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;

        // Reduce player lives
        player_lives -= 1;

        // Update stat bar
        stat_bar_lives();

        // Change border colo(u)r
        document.body.style.background = FLASH_BORDER_COL;

        // Check for player death
        if( player_lives <= 0 )
        {
            // Game over
            setTimeout( game_over_screen, ACTION_PAUSE_DELAY );
        }
        else
        {
            // Change game state to 'lost life'
            game_state = GAME_STATE_LOST_LIFE;

            // Hack to always restart timer for level 10
            if( current_level !== 9 
                &&( level_timer > 0 && !level_restart )
            )
            {
                // Wait a while then move player to last checkpoint
                // and restart the game
                setTimeout( restart_game, ACTION_PAUSE_DELAY );
            }
            // Hack to redisplay info screen for levels 8
            else if( current_level == 7 )
            {
                // Wait a while then restart level from beginning
                setTimeout(
                    function() {
                        level_intro_screen( current_level );
                    },
                    ACTION_PAUSE_DELAY
                );
            }
            else
            {
                // Wait a while then restart level from beginning
                setTimeout(
                    function() {
                        draw_level( current_level );
                    },
                    ACTION_PAUSE_DELAY
                );
            }
        }
    }

    //! Restart game after lost life
    restart_game = function()
    {
        const NEW_CH_I = player_sprite.last_checkpoint[0];
        const NEW_CH_J = player_sprite.last_checkpoint[1];

        console.log( "Restarting game", NEW_CH_I, NEW_CH_J );
        
        // Change border colo(u)r
        document.body.style.background = DEFAULT_BORDER_COL;

        // Remove 'scent trail' from current location
        get_char( player_sprite ).scent = DIR_NONE; 

        // Get current ticks for timing purposes
        const TICKS = Date.now();

        // Move player to last checkpoint
        if( player_sprite.move_whole_chars( NEW_CH_I, NEW_CH_J ) )
        {
            player_sprite.char_i = NEW_CH_I;
            player_sprite.char_j = NEW_CH_J;

            // Reset number of chars fallen
            player_sprite.chars_fallen = 0;

            // Update previous move ticks
            player_sprite.prev_move_ticks = TICKS;
        }

        // Reset all enemy move timings.
        // Also reset position of enemies, but only if a start
        // position is specified
        for( let n = 0; n < enemy_sprites.length; n++ )
        {
            const enemy = enemy_sprites[n];

            enemy.prev_move_ticks = TICKS;

            if( 'start_char_i' in enemy
                && 'start_char_j' in enemy
            )
            {
                enemy.move_whole_chars(
                    enemy.start_char_i,
                    enemy.start_char_j
                );

                enemy.char_i = enemy.start_char_i;
                enemy.char_j = enemy.start_char_j;

                // Reset direction also
                enemy.dir = ENEMY_START_DIR[enemy.type - 1];
            }
        }

        game_state = GAME_STATE_IN_PLAY;

        // Add key handler, this is IMPORTANT
        // as key handler will have been disabled
        // by calling function 'player_loses_life'.
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }
        
        // Restart main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    }

    
    //! Clear all pixels (and delete all sprites)
    clear_screen = function( bg_col = DEFAULT_BG_COL )
    {
        // Clear main game area
        clear_canvas( CANV_CHARS_CTX, chars, bg_col );

        // Clear stat bar
        clear_canvas( CANV_SB_CTX, sb_chars, bg_col );

        delete_all_sprites();
    }

    //! Draw mouse activation screen
    /* This is necessary as most browsers require some
       kind of user interaction to play audio, and mouse
       click is better than key press as some keys trigger
       unwanted browser actions
    */
    mouse_activation_screen = function()
    {
        // CHECK FOR MOUSE INTERACTION TO INITIALIZE GAME
        document.addEventListener( 'click', mouse_init_audio );

        game_state = GAME_STATE_AWAITING_MOUSE_CLICK;

        console.log( "Mouse activation screen" );

        clear_screen( 'black' );

        write_mesg(
            [ "DR. HORRIBLE'S CASTLE",
              "",
              "* CLICK THIS WINDOW *",
              "TO ACTIVATE",
              "BROWSER GAME"
            ],
            1,
            0,
            true,
            true,
            'cyan'
        );
    }

    //! Draw Title Screen
    title_screen = function( col, bitmap_px_width, bitmap_px_height, block_width )
    {
        // Pause key handling
        key_handling_delay = true;

        // Change game state
        game_state = GAME_STATE_TITLE;

        console.log( "Title screen" );
    
        clear_screen( DEFAULT_BG_COL );
        
        // Set fill colo(u)r
        CANV_CHARS_CTX.fillStyle = col;
        
        document.body.style.background = DEFAULT_BORDER_COL;

        // Sanity check
        if( bitmap_px_width * bitmap_px_height / block_width
                !== TITLE_SCREEN_BITMAP_DATA.length
        )
        {
            console.log( "Error: TITLE_SCREEN_BITMAP_DATA",
                         "not expected size.",
                         "bitmap_px_wide =", bitmap_px_width,
                         "bitmap_px_high =", bitmap_px_height,
                         "block_width =", block_width,
                         "bitmap data array length =",
                         TITLE_SCREEN_BITMAP_DATA.length
                       );
            return;
        }

        // Draw title bitmap
        let block_num = 0;
        let bit_pos = 0;
        let block_datum = TITLE_SCREEN_BITMAP_DATA[block_num];
        for( let px_j = 0; px_j < bitmap_px_height ; px_j++ )
        {
            for( let px_i = 0; px_i < bitmap_px_width; px_i++ )
            {
                // Only set colo(u)r of pixels set to '1' in bitmap
                const BIT_MASK = 1 << ( block_width - 1 - bit_pos );
                if( ( BIT_MASK & block_datum ) !== 0 )
                {
                    // Draw pixel
                    CANV_CHARS_CTX.fillRect(
                        px_i * PIXEL_WIDTH,
                        px_j * PIXEL_HEIGHT,
                        PIXEL_WIDTH,
                        PIXEL_HEIGHT
                    );
                }

                // Move 'bit_pos' on
                bit_pos += 1;

                // Check for end of current block
                if( bit_pos == block_width )
                {
                    bit_pos = 0;
                    block_num += 1;
                    if( block_num < TITLE_SCREEN_BITMAP_DATA.length )
                    {
                        block_datum
                            = TITLE_SCREEN_BITMAP_DATA[block_num];
                    }
                }
            }
        }
        
        // Write game title
        write_line( "DR. HORRIBLE'S CASTLE", 
            Math.floor(
                ( CHARS_WIDE - 20 ) / 2
            ),
            CHARS_HIGH - 3,
            'white'
        );

        // Write copyright message
        write_line(
            "M=MUTE " + CHAR_COPYRIGHT + "MUCKYTATERS 2024", 
            0, //CHARS_WIDE - 17,
            CHARS_HIGH - 1,
            col
        );

        stat_bar_alert( "PRESS SPACE TO BEGIN" );

        // Add key handler (defined further on)
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Allow a short wait to allow keyboard activity
        // to cease before checking for key down
        setTimeout(
            function() { key_handling_delay = false; },
            KEY_ENTRY_DELAY
        );
    }

    //! Shared code for screen functions
    draw_screen = function(
        new_game_state,  // Must be a valid game state
        text = [ "" ],  // 1D array of strings
        footer = "",  // String
        centered = true,  // false = left justified
        fg_col = 'cyan',
        bg_col = 'black',
        footer_col = 'purple'
    )
    {
        // Pause key handling
        key_handling_delay = true;

        if( isFinite( new_game_state )
            && new_game_state >= 0
            && new_game_state < GAME_STATE_MAX
        )
        {
            game_state = new_game_state;
        }
        else
        {
            console.log( "Invalid game state:", new_game_state );
            console.log( "Text:", text );
            return false;
        }

        clear_screen( bg_col );
        
        document.body.style.background = DEFAULT_BORDER_COL;

        let error_free = true;

        // Write title to stat bar
        stat_bar_alert( "DR. HORRIBLE'S CASTLE", bg_col, fg_col );

        // Write text
        if( text !== [] )
        {
            error_free |= write_mesg(
                text,
                1,
                1,
                centered,
                false,
                fg_col,
                bg_col
            );
        }

        // Write footer
        if( footer !== [] )
        {
            error_free |= write_line(
                footer,
                CHARS_WIDE - footer.length - 1,
                CHARS_HIGH - 1,
                footer_col,
                bg_col
            );
        }
        
        // Add key handler (defined further on)
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Allow a short wait to allow keyboard activity
        // to cease before checking for key down
        setTimeout(
            function() { key_handling_delay = false; },
            KEY_ENTRY_DELAY
        );
    }

    //! Draw blerb screen giving background narrative
    blerb_screen = function()
    {
        draw_screen( GAME_STATE_BLERB,
                     [ "You are trapped in the",
                       "dungeons of",
                       "Castle Horrible",
                       "Collect keys to escape",
                       "Watch out for monsters",
                       "Be quick or you will",
                       "meet Dr H himself!" ],
                     "press space"
                   );
    
        console.log( "Blerb screen" );
    }

    //! Draw game menu screen
    menu_screen = function()
    {
        draw_screen( GAME_STATE_MENU,
                     [ "Choose an option:",
                       "1. Help/Intructions",
                       "2. Start at level 1",
                       "3. Select start level",
                       "4. About" ],
                     "hit a number key",
                     false
                   );
    
        console.log( "Menu screen" );
    }

    //! Draw game instruction screen 1
    instruction_screen_1 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_1,
                     [ "A spooky platform game.",
                       "WASD IJKL "
                          + CHAR_UP + CHAR_LEFT
                          + CHAR_DOWN + CHAR_RIGHT
                       + " to move.",
                       "Collect all keys to",
                       "complete level.",
                       "Monsters and skulls",
                       "are deadly, but ok to",
                       "climb/drop onto skulls."
                     ],
                     "1/3        press space",
                     false
                   );
    
        console.log( "Instruction screen 1" );
    }

    //! Draw game instruction screen 2
    instruction_screen_2 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_2,
                     [ "Climb onto things by",
                       "jumping up and quickly",
                       "moving left or right.",
                       "A fall of 5 or more",
                       "squares is fatal.",
                       "If timer reaches zero",
                       "Dr H comes to kill you."
                     ],
                     "2/3        press space",
                     false
                   );
    
        console.log( "Instruction screen 2" );
    }

    //! Draw game instruction screen 3
    instruction_screen_3 = function()
    {
        draw_screen( GAME_STATE_INSTRUCTIONS_3,
                     [ "The boring stuff:",
                       "P to pause/unpause",
                       "M to mute/FX/FX+music",
                       "ESC to quit(y/n)",
                       "R to restart level(y/n)",
                       "Restart loses 1 life",
                       ".....Good luck!"
                     ],
                     "3/3        press space",
                     false
                   );
    
        console.log( "Instruction screen 3" );
    }

    //! Draw select starting level screen
    select_level_screen = function()
    {
        // Reset these values (if needed)
        select_level_first_digit = NO_DIGIT_SELECTED;
        cheat_code_first_alpha = NO_DIGIT_SELECTED;
        cheat_code_second_alpha = NO_DIGIT_SELECTED;

        // Check how many numeric digits required
        if( max_level_achieved == 0 )
        {
            // Cheat code only version
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Enter a three letter",
                           "'cheat' code, or ESC",
                           "to return to menu.",
                           "",
                           "(you get a code after",
                           "completing each level)"
                         ],
                         "hit letters or ESC",
                       );
            console.log( "Select level screen (cheat only)" );
        }
        else if( max_level_achieved > 8 )
        {
            // Two digit version
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Select starting level",
                           "01 to " + ( max_level_achieved + 1 ),
                           "(type two digits)",
                           "--- or ---",
                           "enter a three letter",
                           "'cheat' code."
                         ],
                         "hit letters or numbers",
                       );
            console.log( "Select level screen (2 digit)" );
        }
        else
        {
            draw_screen( GAME_STATE_SELECT_LEVEL,
                         [ "Select starting level",
                           "1 to " + ( max_level_achieved + 1 ),
                           "--- or ---",
                           "enter a three letter",
                           "'cheat' code."
                         ],
                         "hit letters or numbers",
                       );
            console.log( "Select level screen" );
        }
    }

    // Processing response to key stroke when in select level mode
    select_level = function( key_code )
    {
        if( key_code == "Escape" )
        {
            menu_screen(); 
        }
        if( key_code.substring( 0, 5 ) == "Digit" )
        {
            // If number pressed, cancel any alpha selection
            cheat_code_first_alpha == NO_DIGIT_SELECTED;
            cheat_code_second_alpha == NO_DIGIT_SELECTED;
            draw_char( 0, CHARS_HIGH - 3, 32 );
            draw_char( 1, CHARS_HIGH - 3, 32 );

            const DIGIT = Number( key_code.substring( 5, 6 ) );

            if( max_level_achieved < 9 )
            {
                // Single digit option...

                // Put choice in bottom left corner
                draw_char( 0, CHARS_HIGH - 2, DIGIT + 48 );

                const LEVEL_ID = Number( key_code.substring( 5, 6 ) ) - 1;
                
                if( LEVEL_ID >= 0
                    && LEVEL_ID <= max_level_achieved
                )
                {
                    player_score = 0;
                    current_level = LEVEL_ID;
                    start_level = LEVEL_ID;
                    player_lives = PLAYER_START_LIVES;

                    // Put tick in after number
                    draw_char( 1, CHARS_HIGH - 2, TICK_ASCII ); 

                    // Start level intro after short delay
                    setTimeout(
                        function() { level_intro_screen( LEVEL_ID ); },
                        250
                    );
                }
                else
                {
                    // Put cross in after number
                    draw_char( 1, CHARS_HIGH - 2, CROSS_ASCII ); 
                    
                    console.log( "Level", LEVEL_ID + 1, "inaccessible" );

                    // Restart level select after short delay
                    setTimeout(
                        function() { select_level_screen(); },
                        250
                    );
                }
            }
            else
            {
                // Two digit option...

                const DIGIT = Number( key_code.substring( 5, 6 ) );

                if( select_level_first_digit
                        == NO_DIGIT_SELECTED
                )
                {
                    select_level_first_digit = DIGIT;

                    // Put choice in bottom left corner
                    draw_char( 0, CHARS_HIGH - 2, DIGIT + 48 );
                }
                else
                {
                    // Put choice in bottom left corner
                    draw_char( 1, CHARS_HIGH - 2, DIGIT + 48 );
                    
                    // Calculate level ID
                    const LEVEL_ID = select_level_first_digit * 10
                                        + DIGIT - 1;
                    
                    // Reset this value
                    select_level_first_digit = NO_DIGIT_SELECTED;

                    if( LEVEL_ID >= 0
                        && LEVEL_ID <= max_level_achieved
                    )
                    {
                        player_score = 0;
                        current_level = LEVEL_ID;
                        start_level = LEVEL_ID;
                        player_lives = PLAYER_START_LIVES;
                        
                        // Put tick after number
                        draw_char( 2, CHARS_HIGH - 2, TICK_ASCII ); 

                        // Start level intro after short delay
                        setTimeout(
                            function() { level_intro_screen( LEVEL_ID ); },
                            250
                        );
                    }
                    else
                    {
                        console.log( "2 digit level",
                                     LEVEL_ID + 1,
                                     "inaccessible" );
                        
                        // Put cross after number
                        draw_char( 2, CHARS_HIGH - 2, CROSS_ASCII ); 
                        
                        // Restart level select after short delay
                        setTimeout(
                            function() { select_level_screen(); },
                            250
                        );
                    }
                }
            }
        }
        else if( key_code.substring( 0, 3 ) == "Key" )
        {
            // If letter pressed, cancel any number selection
            select_level_first_digit = NO_DIGIT_SELECTED;
            draw_char( 0, CHARS_HIGH - 2, 32 );
            
            // Get ascii code of key press
            const ALPHA = key_code.substring( 3, 4 ).charCodeAt();

            // Ignore any non-letter
            if( ALPHA >= 65 && ALPHA <= 90 )
            {
                if( cheat_code_first_alpha == NO_DIGIT_SELECTED )
                {
                    cheat_code_first_alpha = ALPHA;

                    // Put choice in (almost) bottom left corner
                    draw_char( 0, CHARS_HIGH - 3, ALPHA );
                }
                else if( cheat_code_second_alpha == NO_DIGIT_SELECTED )
                {
                    cheat_code_second_alpha = ALPHA;

                    // Put choice in bottom left corner
                    draw_char( 1, CHARS_HIGH - 3, ALPHA );
                }
                else
                {
                    // Put choice in bottom left corner
                    draw_char( 2, CHARS_HIGH - 3, ALPHA );
                   
                    const N = calc(
                        cheat_code_first_alpha,
                        cheat_code_second_alpha,
                        ALPHA,
                        65
                    );

                    for( let n = 0; n < SPEC.length; n++ )
                    {

                        if( N == SPEC[n] )
                        {
                            draw_char( 3, CHARS_HIGH - 3, TICK_ASCII ); 
                            
                            player_score = 0;
                            current_level = n + 1;
                            start_level = current_level;
                            player_lives = PLAYER_START_LIVES;
                            
                            setTimeout(
                                function() {
                                    level_intro_screen( current_level );
                                },
                                250
                            );
                            return;
                        }
                    }

                    draw_char( 3, CHARS_HIGH - 3, CROSS_ASCII ); 
                    cheat_code_first_alpha = NO_DIGIT_SELECTED;
                    cheat_code_second_alpha = NO_DIGIT_SELECTED;
                    
                    setTimeout(
                        function() { select_level_screen(); },
                        250
                    );
                }
            }
        }
    }

    about_screen = function()
    {
        draw_screen( GAME_STATE_ABOUT,
                     [ "For SCREAM JAM 2024",
                       "Code and graphics:",
                       "(C) MUCKYTATERS 2024",
                       "FREE AND OPEN SOURCE",
                       "Licensed under GPL3",
                       "github.com/MuckyTaters",
                       "Music: Grieg 1875"
                     ],
                     "v1.0   press space/ESC"
                   );
        
        console.log( "About" );
    }

    level_intro_screen = function( level )
    {
        audio_stop_theme();
        
        draw_screen( GAME_STATE_LEVEL_INTRO,
                     LEVEL_INTRO_TEXT[level],
                     "press space to play",
                     true
                   );
        stat_bar_alert(
            "Level " + ( level + 1 ) + " tips:",
            'black',
            'cyan'
        );
    

        // Play evil laugh
        if( audio_mute !== MUTE_STATUS_MUTE_ALL )
        {
            AUDIO.src = AUDIO_EVIL_LAUGH;
            AUDIO.play();
        }

        console.log( "Level", level + 1, "intro" );
    }

    //! Draw game over screen
    game_over_screen = function()
    {
        // Stop audio
        cancel_audio_FX();
        audio_stop_theme();

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;

        // Add key handler, this is IMPORTANT
        // as key handler will have been disabled
        // by calling function 'player_loses_life'.
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        const SCORE_TXT = player_score == player_hi_score ?
                "New high score " : "You scored ";

        draw_screen( GAME_STATE_GAME_OVER,
                     [ "GAME OVER",
                       "You reached level " + ( current_level + 1 ),
                       SCORE_TXT + player_score,
                       "",
                       "Will you ever escape",
                       "Castle Horrible?"
                    ],
                     "press space"
                   );
    
        console.log( "Game over screen" );
    }

    //! Draw level completion screen
    level_completion_screen = function( bonus = 0, finished = false )
    {
        const EXTRA_BONUS_LIFE
            = levels_with_extra_bonus_life.has( current_level );
       
        // If just left game screen, cancel any playing sound FX
        // Also. process life bonus
        if( bonus == 0 )
        {
            cancel_audio_FX();

            player_lives += EXTRA_BONUS_LIFE ? 2 : 1;
        }

        draw_screen( GAME_STATE_COMPLETED_LEVEL,
                     [ "Level " + ( current_level + 1 ) + " complete!",
                       "",
                       "Timer bonus +" + bonus,
                       "",
                       EXTRA_BONUS_LIFE ?
                             "+2 bonus lives!" : "+1 bonus life!",
                       "",
                       "You now have " + player_lives + " lives."
                    ],
                     ""
                   );

        // Decrease timer and add bonus
        if( level_timer > 0 )
        {
            // Play FX only on alternate iterations
            if( bonus % 2 == 0 )
            {
                audio_play_collect_FX();
            }
            else
            {
                cancel_audio_collect_FX();
            }

            level_timer -= 1;
            bonus += 1;
            player_score += 1;
            if( player_score > player_hi_score )
            {
                player_hi_score = player_score;
            }

            // Overwrite stat bar
            stat_bar_update();

            setTimeout( function() {
                    level_completion_screen( bonus )
                },
                100
            );
        }
        // If all timer bonus processed, wait before 
        // moving on
        else if( !finished )
        {
            // Overwrite stat bar
            stat_bar_update();

            setTimeout( function() {
                    // This sets 'finished' to true
                    // for next recursion
                    level_completion_screen( bonus, true )
                },
                2000
            );
        }
        // All done with bonus, now present cheat code
        else
        {
            // Overwrite stat bar
            // Note: this is done BEFORE
            //       level is increased
            stat_bar_update();

            current_level += 1;
            if( current_level > max_level_achieved )
            {
                max_level_achieved = current_level;
            }
        
            console.log( "Waiting for level",
                         current_level
            );

            // Present 'cheat' code
            draw_screen( GAME_STATE_BONUS_FINISHED,
                         [ "To skip to level " + ( current_level + 1 ), 
                           "in future browser",
                           "sessions, write down",
                           "this 'cheat' code: ",
                           "",
                           "" + recalc( SPEC[current_level - 1] )
                         ],
                         "press space"
                       );

            // Game now waits for user to press space
        }
    }

    //! Game completion (with cheating)
    game_completion_screen = function()
    {
        draw_screen( GAME_STATE_GAME_COMPLETED_WITH_CHEATS,
                     [ "Well done, you have",
                       "completed the final",
                       "level, starting from",
                       "level " + ( start_level + 1 ) + ".",
                       "To see the true game",
                       "completion screen,",
                       "start at level 1!"
                    ],
                     "press space"
                   );

        // Show score etc.
        stat_bar_update();

        console.log( "Game completion (with cheats) screen" );
    }

    //! Game completion (without cheating)
    true_game_completion_screen = function( phase = 0 )
    {
        // Flag set to true once sequence is complete
        const AT_END = phase >= DR_H_DEATH.length;
        
        // Play end tune
        if( phase == 0 )
        {
            audio_stop_theme();
            
            // If FX only, unmute so that theme now plays
            if( audio_mute == MUTE_STATUS_FX_ONLY )
            {
                audio_mute = MUTE_STATUS_FULL_AUDIO;
                unmute();
            }

            // Set theme to be loud
            audio_theme_oscillator.type = 'square';
            audio_theme_gain.gain.value = audio_master_gain * 2;
            
            audio_play_tune(
                audio_theme_oscillator,
                audio_theme_gain,
                AUDIO_THEME_DATA,
                74,  // start halfway through
                false,  // no repeat
                3.0,  // hi-speed
                -12,  // one octave lower
            );

            draw_screen( GAME_STATE_GAME_COMPLETED_SEQUENCE,
                         [ "!! You win !!",
                           "Dr H has met his match!"
                        ],
                        ""
                       );
            
            // Show score etc.
            stat_bar_update();

            // Draw Dr Horrible
            draw_charx8(
                Math.round( ( CHARS_WIDE - 8 ) * 0.80 ), 
                5,  // vert pos
                DR_H_ASCII,
                DR_H_DEATH[phase],
                DR_H_COL
            );

            // Draw player
            draw_charx8(
                Math.round( ( CHARS_WIDE - 8 ) * 0.20 ), 
                5,  // vert pos
                PLAYER_CHAR_ASCII,
                32,
                PLAYER_COL
            );
        }
        else
        {
            // Draw Dr Horrible
            draw_charx8(
                Math.round( ( CHARS_WIDE - 8 ) * 0.80 ), 
                5,  // vert pos
                DR_H_ASCII,
                AT_END? 32 : DR_H_DEATH[phase],
                AT_END? DEFAULT_BG_COL : DR_H_COL,
                DEFAULT_BG_COL,
                true  // Draw only foreground blocks (for speed)
            );

            console.log( "Game completion (without cheats) screen",
                         phase );
        }
        
        if( AT_END )
        {
            // Write footer
            const FOOTER = "press space to exit";
            write_line(
                FOOTER,
                CHARS_WIDE - FOOTER.length - 1,
                CHARS_HIGH - 1,
                'purple'
            );

            // Player can now press space to return to main menu
            game_state =  
                GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS;
        }
        else
        {
            // If not end, set callback for next sequence
            setTimeout( function() {
                true_game_completion_screen( phase + 1 )
                },
                500
            );
        }
    }

    //! Character graphic data quality check
    char_qual_check = function( c )
    {
        if( !isFinite( c )
            || c < 0
            || c > 255
        )
        {
            console.log( "Error: character code", c,
                         "is non-number or out-of-bounds (0-255)." );
            return false;
        }
        
        const NUM_ROWS = ASCII_DATA[c].length;

        if( NUM_ROWS == 0 )
        {
            console.log( "Error: no graphic data for ascii code", c );
            return false;
        }
        
        if( NUM_ROWS !== 8 )
        {
            console.log( "Error: graphic data for ascii code", c,
                         "has", NUM_ROWS, "rows, should be 8." );
            return false;
        }

        return true;
    }

    //! Draw ascii character at x8 scale
    draw_charx8 = function(
        i,
        j,
        c,
        pixel_ascii = 32,
        fg = DEFAULT_FG_COL,
        bg = DEFAULT_BG_COL,
        draw_fg_only  // Only draw 'foreground' blocks
    )
    {
        // Check char 'c' is valid
        if( !char_qual_check( c ) ) { return false; }

        const BLOCK = ASCII_DATA[c];

        for( let n = 0; n < 8; n++ )
        {
            const LINE = BLOCK[n];

            for( let m = 0; m < 8; m++ )
            {
                // Set 'BIT' to true if bit is 1, false if 0
                const BIT = ( ( LINE << m ) & 0b10000000 ) > 0;

                if( BIT )
                {
                    // If pixel ascii is space, reverse fg and bg
                    if( pixel_ascii == 32 )
                    {
                        draw_char(
                            i + m,
                            j + n,
                            32,
                            bg,  // Note reversal of fg/bg
                            fg
                        );
                    }
                    // Otherwise, just draw the char
                    else
                    {
                        draw_char(
                            i + m,
                            j + n,
                            pixel_ascii,
                            fg,
                            bg
                        );
                    }
                }
                else if( !draw_fg_only )
                {
                    draw_char( i + m, j + n, 32, fg, bg );
                }
            }
        }

        return true;
    }

    //! Draw char on stat bar
    /*! @param i: Horizontal pos (in whole character tiles)
     *  @param c: ASCII value of character
     *  @param fg: Foreground colo(u)r (as string)
     *  @param bg: Background colo(u)r (as string)
     */
    draw_char_sb = function( i, c, fg = DEFAULT_FG_COL, bg = DEFAULT_BG_COL )
    {
        return draw_char( i, 0, c, fg, bg, true );
    }

    //! Write line
    write_line = function( 
        line,
        start_char_i,
        char_j,
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        if( char_j < 0 || char_j >= CHARS_HIGH )
        {
            console.log( "Line write veritcal pos out-of-bounds." );
            return false;
        }

        if( start_char_i < 0 )
        {
            console.log( "Line write underflow." );
            return false;
        }

        let cursor_i = start_char_i;

        for( let n = 0; n < line.length; n++ )
        {
            if( cursor_i >= CHARS_WIDE )
            {
                console.log( "Line write overflow." );
                return false;
            }

            draw_char(
                cursor_i,
                char_j,
                line.charCodeAt( n ),
                fg_col,
                bg_col
            );
            
            // Move to next char
            cursor_i += 1;
        }
            
        return true;
    }

    //! Write message, centered hoz and veritcally
    write_mesg = function( mesg,
                           hoz_margin_in_chars = 0,
                           vert_margin_in_chars = 0,
                           hoz_centered = true,
                           vert_centered = true,
                           fg_col = DEFAULT_FG_COL,
                           bg_col = DEFAULT_BG_COL
                )
    {
        let error_free = true;

        // Calculate starting vert cursor pos
        let cursor_char_j = vert_centered ?
                Math.floor(
                    ( CHARS_HIGH - mesg.length * 2 + 1 ) / 2
                ) : 0;

        // Constrain within margins
        cursor_char_j
            = Math.min( 
                Math.max( cursor_char_j, vert_margin_in_chars ),
                CHARS_HIGH - vert_margin_in_chars
            );

        // Process each line
        for( let p = 0; p < mesg.length; p++ )
        {
            const ln = mesg[p];
        
            let cursor_char_i = hoz_centered ?
                Math.floor(
                    ( CHARS_WIDE - ln.length ) / 2
                ) : 0;

            // Constrain within margins
            cursor_char_i
                = Math.min( 
                    Math.max( cursor_char_i, hoz_margin_in_chars ),
                    CHARS_WIDE - hoz_margin_in_chars
                );

            error_free |= write_line(
                ln,
                cursor_char_i,
                cursor_char_j,
                fg_col,
                bg_col
            );

            // Move to next line (including an extra line of space)
            cursor_char_j += 2;
        }

        return error_free;
    }

    // Clear one line message to stat bar
    stat_bar_alert = function(
        mesg,
        fg_col = STAT_ALERT_FG_COL,
        bg_col = STAT_ALERT_BG_COL,
        blank_char_code = 32
    )
    {
        let cursor_char_i
            = Math.floor(
                ( CHARS_WIDE - mesg.length ) / 2
            );

        for( let n = 0; n < cursor_char_i; n++ )
        {
            draw_char_sb( n, blank_char_code, fg_col, bg_col ); 
        }

        for( let n = 0; n < mesg.length; n++ )
        {
            draw_char_sb(
                cursor_char_i,
                mesg.charCodeAt( n ),
                fg_col,
                bg_col
            );
            
            // Move to next char
            cursor_char_i += 1;
        }
        
        for( let n = cursor_char_i; n < CHARS_WIDE; n++ )
        {
            draw_char_sb( n, blank_char_code, fg_col, bg_col ); 
        }
  
        if( mute ) { stat_bar_mute(); }
    }

    clear_stat_bar = function( bg_col = STAT_BG_COL )
    {
        stat_bar_alert( "", bg_col, bg_col );
    }

    stat_bar_lives = function()
    {
        const BASE_I = STAT_BAR_LEVEL_DIGITS;

        for( let n = 0; n < STAT_BAR_LIVES_MAX; n++ )
        {
            if( n < player_lives )
            {
                draw_char_sb(
                    BASE_I + n,
                    PLAYER_CHAR_ASCII,
                    STAT_LIVES_COL,
                    STAT_BG_COL
                );
            }
            else
            {
                draw_char_sb(
                    BASE_I + n,
                    STAT_BAR_EMPTY_ASCII,
                    STAT_LIVES_COL,
                    STAT_BG_COL
                );
            }
        }
    }

    stat_bar_number = function(
        num,
        char_i,
        digits,
        fg_col = STAT_NUM_COL,
        bg_col = STAT_BG_COL
    )
    {
        let cursor_i = char_i + digits - 1;
        
        const NUM_AS_STRING = '' + num;
        const LEN = NUM_AS_STRING.length;
        const ACTIVE_DIGITS
            = Math.min( digits, LEN );
        const INACTIVE_DIGITS
            = digits - ACTIVE_DIGITS;

        // Draw active digits
        for( let n = 0; n < ACTIVE_DIGITS; n++ )
        {
            draw_char_sb(
                cursor_i,
                NUM_AS_STRING.charCodeAt( LEN - 1 - n ),
                fg_col,
                bg_col
            );

            cursor_i -= 1;
        }

        // Draw leading zeros
        const Z = '0'.charCodeAt( 0 );  // ASCII zero;
        for( let n = 0; n < INACTIVE_DIGITS; n++ )
        {
            draw_char_sb(
                cursor_i,
                Z,
                fg_col,
                bg_col
            );

            cursor_i -= 1;
        }
    }

    stat_bar_level = function()
    {
        stat_bar_number(
            current_level + 1,
            0,
            STAT_BAR_LEVEL_DIGITS
        );
    }

    stat_bar_score = function()
    {
        stat_bar_number(
            player_score, 
            STAT_BAR_LEVEL_DIGITS + STAT_BAR_LIVES_MAX,
            STAT_BAR_SCORE_DIGITS
        );
    }

    stat_bar_hi_score = function()
    {
        stat_bar_number(
            player_hi_score, 
            STAT_BAR_LEVEL_DIGITS 
                + STAT_BAR_LIVES_MAX + STAT_BAR_SCORE_DIGITS + 1,
            STAT_BAR_SCORE_DIGITS
        );
    }

    stat_bar_timer = function()
    {
        if( level_timer < 0 )
        {
            console.log( "level_timer", level_timer );
            const FLAG = level_timer % 2 == -1;
            stat_bar_number(
                0, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                FLAG ? STAT_TIMER_FG_COL : STAT_TIMER_BG_COL,
                !FLAG ? STAT_TIMER_FG_COL : STAT_TIMER_BG_COL
            );
            
        }
        else if( level_timer >= 10 )
        {
            stat_bar_number(
                level_timer, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                STAT_TIMER_FG_COL,
                STAT_TIMER_BG_COL
            );
        }
        else
        {
            // If timer in single digits, reverse colo(u)rs
            stat_bar_number(
                level_timer, 
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS,
                STAT_BAR_TIMER_DIGITS,
                STAT_TIMER_BG_COL,  // Note colo(u)r reversal
                STAT_TIMER_FG_COL
            );
        }
    }

    stat_bar_mute = function()
    {
        // Check game state, as this will determine where
        // mute symbol is placed.
        const IN_GAME = 
            game_state == GAME_STATE_IN_PLAY
            || game_state == GAME_STATE_LOST_LIFE
            || game_state == GAME_STATE_COMPLETED_LEVEL
            || game_state == GAME_STATE_GAME_COMPLETED_WITH_CHEATS
            || game_state == GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS
            || game_state == GAME_STATE_GAME_COMPLETED_SEQUENCE;

        // Determine character to represent
        // current mute status
        let c = MUTE_ASCII;
        if( audio_mute == MUTE_STATUS_FX_ONLY )
        {
            // If in game, use blank (i.e. space)
            c = IN_GAME ? 32 : FX_ONLY_ASCII;
        }
        else if( audio_mute == MUTE_STATUS_FULL_AUDIO )
        {
            // If in game, use blank (i.e. space)
            c = IN_GAME ? 32 : NO_MUTE_ASCII;
        }

        if( IN_GAME )
        {
            draw_char_sb(
                CHARS_WIDE - STAT_BAR_TIMER_DIGITS - 1,
                c,
                STAT_NUM_COL,
                STAT_BG_COL
            );
        }
        else
        {
            draw_char_sb(
                CHARS_WIDE - 1,
                c,
                STAT_ALERT_FG_COL,
                STAT_ALERT_BG_COL
            );
        }
    }

    stat_bar_update = function()
    {
        clear_stat_bar();
        stat_bar_level();
        stat_bar_lives();
        stat_bar_score();
        stat_bar_hi_score();
        stat_bar_timer();
        stat_bar_mute();
    }

    //! Draw level
    /*! @param level_id: Level ID (starting at zero)
     */
    draw_level = function( level_id, ctx = CANV_CHARS_CTX )
    {
        console.log( "draw_level" );

        // Update game state
        game_state = GAME_STATE_BUILDING_LEVEL;
        
        // Set border colo(u)r to default
        document.body.style.background = DEFAULT_BORDER_COL;

        // Remove any existing sprites
        delete_all_sprites();
        
        // Create 'div' to hold all sprite 'div's
        top_sprite_div = document.createElement( "div" );
        top_sprite_div.id = "top_sprite_div" ;
        top_sprite_div.className = "div_class";
        top_sprite_div.style.width = "100%";
        top_sprite_div.style.height = "100%";
        top_div.appendChild( top_sprite_div );

        // Get reference to level data
        const LEVEL = LEVEL_DATA[ level_id ];

        // Set custom colo(u)r palette
        if( LEVEL_PALETTE.length > level_id )
        {
            custom_colors = LEVEL_PALETTE[ level_id ];
        }
        else
        {
            custom_colors = {};
        }

        // Set foreground colo(u)r, or use default
        const LEVEL_FG_COL = 'foreground' in custom_colors ?
                            custom_colors['foreground'] :
                            DEFAULT_FG_COL;

        // Set background colo(u)r, or use default
        const LEVEL_BG_COL = 'background' in custom_colors ?
                            custom_colors['background'] :
                            DEFAULT_BG_COL;

        // Player start pos, to be determined from level map
        let player_i = 0;
        let player_j = 0;

        // This is used to cycle through colo(u)rs for collectables
        let collectable_color_index = 0;

        // Clear collectables set, it will be filled in 
        // following loop
        if( collectables.size > 0 ) { collectables.clear(); }

        for( let j = 0; j < CHARS_HIGH; j++ )
        {
            // Get reference to level line
            const LEVEL_LINE = LEVEL[j];

            for( let i = 0; i < CHARS_WIDE; i++ )
            {
                // Get i'th symbol on line
                const SYMBOL = LEVEL_LINE.substr( i, 1 );

                const SYMBOL_RAW_ASCII = SYMBOL.charCodeAt( 0 );

                // Treat certain punctation marks and all uppercase
                // letters as bricks for solidity purposes,
                // but otherwise render them as-is.
                // This flag actions this further on.
                const ALPHA = SYMBOL_RAW_ASCII == 32  // SPACE
                              || SYMBOL_RAW_ASCII == 33  // !
                              || SYMBOL_RAW_ASCII == 63  // ?
                              ||( SYMBOL_RAW_ASCII >= 65
                                  && SYMBOL_RAW_ASCII <= 90 );

                // Quality check
                if( !ALPHA && !( SYMBOL in LEVEL_NOTATION ) )
                {
                    // Error, unknown symbol in level map
                    console.log( "Unknown symbol: '",
                                 SYMBOL,
                                 "' in map of level ",
                                 level_id );
                    draw_char( i, j, LEVEL_NOTATION["UNKNOWN"] );

                    // Move to next char
                    continue;
                }

                // Process player start location
                if( SYMBOL == 'p' )
                {
                    player_i = i;
                    player_j = j;
                    player_start_char_i = i;
                    player_start_char_j = j;
                }

                // Process player checkpoint
                if( SYMBOL == 'j' || SYMBOL == 'k' )
                {
                    chars[j][i].checkpoint = true;
                }
                else
                {
                    chars[j][i].checkpoint = false;
                }

                // Create enemy sprite
                if( SYMBOL in ENEMY_LEVEL_NOTATION )
                {
                    const SPRITE_TYPE
                        = ENEMY_LEVEL_NOTATION[SYMBOL];

                    const ENEMY_INDEX = SPRITE_TYPE - 1;

                    const CHAR_ID = ENEMY_SPRITE_ASCII[ENEMY_INDEX];

                    // Check 'CHAR_ID' is valid
                    if( !char_qual_check( CHAR_ID ) )
                    {
                        console.log( "Error with image data",
                                     "for sprite type",
                                     SPRITE_TYPE,
                                     ", ignoring sprite at",
                                     i, j );
                        continue;
                    }

                    let enemy
                        = sprite(
                            // Note enemy number added to ID:
                            "enemy_sprite_" + enemy_sprites.length, 
                            i * PX_PER_CHAR_HOZ,
                            j * PX_PER_CHAR_VERT,
                            ASCII_DATA[CHAR_ID],
                            ENEMY_COL[ENEMY_INDEX],
                            SPRITE_TYPE
                        );
        
                    // Add extra variables for enemy sprite
                    enemy['char_i'] = i;  // Hoz
                    enemy['char_j'] = j;  // Vert
              
                    enemy['dir'] = ENEMY_START_DIR[ENEMY_INDEX];
                    enemy['ticks_per_move']
                        = ENEMY_TICKS_PER_MOVE[ENEMY_INDEX];
                    enemy['prev_move_ticks'] = -1;

                    // For certain enemy types, remember
                    // start position
                    if( ENEMY_POS_RESET[ENEMY_INDEX] )
                    {
                        enemy['start_char_i'] = i;
                        enemy['start_char_j'] = j;
                    }

                    enemy_sprites.push( enemy );
                    all_sprites.push( enemy );
                }

                // Look up ASCII value for symbol 
                // (for uppercase letters, use raw ASCII)
                const C = ALPHA ? SYMBOL_RAW_ASCII :
                                  LEVEL_NOTATION[SYMBOL];
               
                // Declare fore and background colo(u)rs
                fg_col = LEVEL_FG_COL;
                bg_col = LEVEL_BG_COL;

                // Check if custom colo(u)rs specified for SYMBOL
                if( SYMBOL == 'c' )
                {
                    // For collectable items
                    // pick a colo(u)r from the colo(u)r cycle
                    fg_col = LEVEL_COLLECTABLE_COLOR_CYCLE[
                        collectable_color_index
                    ];

                    // Move colo(u)r cycle on
                    collectable_color_index
                        = ( collectable_color_index + 1 )
                            % LEVEL_COLLECTABLE_COLOR_CYCLE.length;

                }
                else if( ALPHA && 'alpha' in custom_colors )
                {
                    const COLS = custom_colors['alpha'];
                    
                    if( COLS.length > 1 )
                    {
                        fg_col = COLS[0];
                        bg_col = COLS[1];
                    }
                    else if( COLS.length > 0 )
                    {
                        fg_col = COLS[0];
                    }
                }
                else if( ( ALPHA && ( '=' in custom_colors ) ) 
                         || SYMBOL in custom_colors
                )
                {
                    // For alpha, use brick colo(u)r scheme
                    const COLS = ALPHA ? custom_colors['='] :
                                         custom_colors[SYMBOL];
                    
                    // Custom foreground colo(u)r is always first
                    if( COLS.length > 0 )
                    {
                        if( !ALPHA )
                        {
                            fg_col = COLS[0];
                        }
                        else
                        {
                            // For alpha characters, invert colo(u)rs
                            bg_col = COLS[0];
                        }
                    }

                    // Custom background colo(u)r is optional second
                    if( COLS.length > 1 )
                    {
                        if( !ALPHA )
                        {
                            bg_col = COLS[1];
                        }
                        else
                        {
                            // For alpha characters, invert colo(u)rs
                            fg_col = COLS[1];
                        }
                    }
                }
                
                // Draw character
                draw_char(
                    i,
                    j,
                    C,
                    fg_col,
                    bg_col
                );

                // Get refernece to character object
                NEW_CHAR = chars[j][i];

                // Process collectable object location
                if( SYMBOL == 'c' )
                {
                    collectables.add( NEW_CHAR );
                }

                // Add solidity info to character
                if( ALPHA )
                {
                    // Treat uppercase letters as bricks
                    NEW_CHAR.solidity
                        = LEVEL_SOLID_ASCII_VALUES[ LEVEL_BRICK ];
                }
                else if( C in LEVEL_SOLID_ASCII_VALUES )
                {
                    NEW_CHAR.solidity = LEVEL_SOLID_ASCII_VALUES[ C ];
                }
                else
                {
                    NEW_CHAR.solidity = 0;
                }
            }
        }

        // Create player sprite
        player_sprite
            = sprite(
                "player_sprite",
                player_i * PX_PER_CHAR_HOZ,
                player_j * PX_PER_CHAR_VERT,
                ASCII_DATA[PLAYER_CHAR_ASCII],
                PLAYER_COL
            );

        // Add extra variables to player sprite...

        // Position of sprite in whole character square coords
        player_sprite['char_i'] = player_i;  // Hoz
        player_sprite['char_j'] = player_j;  // Vert

        // Time at which last player move took place
        // Note: -ve value indicates no previous move
        player_sprite['prev_move_ticks'] = -1;

        // Number of chars player sprite has fallen
        // Note: 0 indicates player is not falling
        player_sprite['chars_fallen'] = 0;

        // Max number of chars player sprite can fall and live
        player_sprite['max_fall_chars'] = 4;

        // Min number of milliseconds between player sprite moves
        player_sprite['min_move_ticks'] = 250; // 125;

        // Remember if previous move was up
        player_sprite['last_move_up'] = false;

        // Remember last player checkpoint (default to start location)
        player_sprite['last_checkpoint'] = [player_i,player_j];

        // ...end of extra variables/methods
        

        // Store player sprite in list all sprites
        all_sprites['player'] = player_sprite;

        // Change game state to 'in play'
        game_state = GAME_STATE_IN_PLAY;

        // Set timer
        level_timer_max = LEVEL_TIMINGS[level_id];
        level_timer = level_timer_max;

        // Draw stat bar
        stat_bar_update();

        // Start main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    
        // Add key handler (defined further on)     
        if( !key_handler_on )
        {
            document.addEventListener('keydown', handleKeyEvent);
            key_handler_on = true;
        }

        // Start in-play theme
        audio_stop_theme();
        // Note: sine wave (less harsh than square wave)
        audio_theme_oscillator.type = "sine";
        audio_theme_gain.gain.value
                = audio_master_gain * AUDIO_THEME_IN_GAME_GAIN;
        audio_play_tune(
            audio_theme_oscillator,
            audio_theme_gain,
            AUDIO_THEME_DATA,
            0,  // start pos
            true,  // repeat
            2.0  // speed
        );

        // Set reference point for timer
        level_timer_reference_ticks = Date.now();
        level_pause_total_ticks = 0;
        level_pause_ticks = 0;
    }

    // Additional method(s) for sprites that maintain
    // a whole-character position index (e.g. player_sprite)...
    
    // Calculate 'i' offset for given direction
    calc_i_offset = function( direction )
    {
        switch( direction )
        {
            case DIR_UP: return 0; break;
            case DIR_LEFT: return -1; break;
            case DIR_DOWN: return 0; break;
            case DIR_RIGHT: return 1; break;
            case DIR_NONE: return 0; break;
            default:
                console.log( "Unknown dir for i offset", direction );
        }
    }
    
    // Calculate 'j' offset for given direction
    calc_j_offset = function( direction )
    {
        switch( direction )
        {
            case DIR_UP: return -1; break;
            case DIR_LEFT: return 0; break;
            case DIR_DOWN: return 1; break;
            case DIR_RIGHT: return 0; break;
            case DIR_NONE: return 0; break;
            default:
                console( "Unknown dir for j offset", direction );
        }
    }

    //! Get hoz index of a character square offset from sprite's current character square
    get_offset_i = function( this_sprite, offset_i )
    {
        const RAW_ANS = ( this_sprite.char_i + offset_i ) % CHARS_WIDE; 
        return RAW_ANS >= 0 ? RAW_ANS : RAW_ANS + CHARS_WIDE; 
    }

    //! Get vert index of a character square offset from sprite's current character square
    get_offset_j = function( this_sprite, offset_j )
    {
        const RAW_ANS = ( this_sprite.char_j + offset_j ) % CHARS_HIGH; 
        return RAW_ANS >= 0 ? RAW_ANS : RAW_ANS + CHARS_HIGH; 
    }

    //! Get character under sprite (or at offset, in whole chars)
    get_char = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        if( !( ( 'char_i' in this_sprite ) && ( 'char_j' in this_sprite ) ) )
        {
            console.log( "Error, get_char called",
                         "on non-char this_sprite." );
            return;  // Return nothing
        }

        const NEW_I = offset_i == 0 ?
                        this_sprite.char_i :
                        get_offset_i( this_sprite, offset_i );
        
        const NEW_J = offset_j == 0 ?
                        this_sprite.char_j :
                        get_offset_j( this_sprite, offset_j );

        return chars[NEW_J][NEW_I];
    }

    //! Check if character, positioned relative to sprite, is solid
    /*! Returns -1, and logs error, if sprite has no char pos info */
    get_solidity = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        if( !( ( 'char_i' in this_sprite ) && ( 'char_j' in this_sprite ) ) )
        {
            console.log( "Error, solidity check called",
                         "on non-char this_sprite." );
            return -1;
        }

        // Return soldity of char at these indices
        return get_char( this_sprite, offset_i, offset_j ).solidity;
    }

    //! Returns true if char *below* sprite (+ offset) has solid top
    /*! Returns false and logs error, if sprite has no char pos info */
    on_solid_ground = function( this_sprite, offset_i = 0, offset_j = 0 )
    {
        return (
            get_solidity(
                this_sprite,
                offset_i,
                offset_j + 1
            ) & SOLID_TOP
        ) > 0;
    }

    //! Returns true if char below sprite is a ladder
    /*! Returns false and logs error, if sprite has no char pos info */
    can_descend = function( this_sprite )
    {
        const C = get_char( this_sprite, 0, 1 ).char_id;
        return C == LEVEL_LADDER || C == LEVEL_FAKE_BRICK;
    }

    //! Returns true if char to left of sprite is right-permeable
    /*! Returns false and logs error, if sprite has no char pos info */
    can_move_left = function( this_sprite )
    {
            return ( get_solidity( this_sprite, -1, 0 ) & SOLID_RIGHT ) == 0
                   && can_move( this_sprite, DIR_LEFT );
    }

    //! Returns true if char to right of sprite is left-permeable
    /*! Returns false and logs error, if sprite has no char pos info */
    can_move_right = function( this_sprite )
    {
        return ( get_solidity( this_sprite, 1, 0 ) & SOLID_LEFT ) == 0
               && can_move( this_sprite, DIR_RIGHT );
    }

    can_move_left_on_solid_ground = function( this_sprite )
    {
        return can_move_left( this_sprite )
               && on_solid_ground( this_sprite, -1, 0 );
    }

    can_move_right_on_solid_ground = function( this_sprite )
    {
        return can_move_right( this_sprite )
               && on_solid_ground( this_sprite, 1, 0 );
    }

    can_move_on_solid_ground = function( this_sprite, direction )
    {
        switch( direction )
        {
            case DIR_UP:
                return get_char( this_sprite ).char_id
                            == LEVEL_LADDER
                       && can_move( this_sprite, DIR_UP );
            
            case DIR_RIGHT:
                return can_move_right_on_solid_ground( this_sprite );
            
            case DIR_DOWN:
                return can_descend( this_sprite );
            
            case DIR_LEFT:
                return can_move_left_on_solid_ground( this_sprite );
            
            default:
                return false;
        }
    }

    //! Returns true if char in direction 'dir' is permeable
    /*! Returns false and logs error, if 'dir' is invalid,
     *  or sprite has no char pos info */
    can_move = function( this_sprite, dir )
    {
        switch( dir )
        {
            case DIR_UP:
                return ( get_solidity( this_sprite, 0, -1 ) & SOLID_BOTTOM ) == 0;
                break;

            case DIR_LEFT:
                if( !'char_i' in this_sprite )
                {
                    console.log( "Error, sprite has no 'char_i'" );
                    return false;
                }
                return this_sprite.char_i > 0
                       && ( get_solidity( this_sprite, -1, 0 ) & SOLID_RIGHT ) == 0;
                break;

            case DIR_DOWN:
                return ( get_solidity( this_sprite, 0, 1 ) & SOLID_TOP ) == 0;
                break;

            case DIR_RIGHT:
                if( !'char_i' in this_sprite )
                {
                    console.log( "Error, sprite has no 'char_i'" );
                    return false;
                }

                return this_sprite.char_i < ( CHARS_WIDE - 1 )
                       && ( get_solidity( this_sprite, 1, 0 ) & SOLID_LEFT ) == 0;
                break;

            default:
                console.log( "Error, unrecognized direction:", dir );
                return false;
        }
    }


    //////////////////////////////////////
    // Main loop processing
    function main_loop()
    {
        // Get current time, in ticks
        const TICKS = Date.now();

        // Get time since previous frame, in milliseconds
        // (if no previous frame, use FRAME_DURATION as default )
        const TICKS_ELAPSED = prev_ticks < 0 ?
                                FRAME_DURATION :
                                TICKS - prev_ticks;
        
        // Calculate ticks elapsed as proportion of desired
        // frame duration
        const FRAME_SCALE = TICKS_ELAPSED / FRAME_DURATION;

        // console.log( TICKS_ELAPSED, FRAME_SCALE );

        // Calculate this for next frame
        prev_ticks = TICKS;

        // Check if timer needs updating
        {
            const TIME_REMAINING
                = level_timer_max
                    - Math.floor( 
                        ( TICKS - level_timer_reference_ticks
                                    - level_pause_total_ticks )
                            / 1000
                    );

            if( TIME_REMAINING !== level_timer )
            {
                level_timer = TIME_REMAINING;

                if( audio_mute !== MUTE_STATUS_MUTE_ALL
                    && level_timer < 10
                )
                {
                    // Play alert audio FX
                    audio_alert_fx_oscillator.frequency.value
                        = AUDIO_FX_ALERT_FREQ;
                    audio_alert_fx_oscillator
                        .connect( audio_alert_fx_gain )
                            .connect( audio_context.destination);
                    setTimeout(
                        function () { cancel_audio_alert_FX(); },
                        AUDIO_FX_ALERT_DURATION 
                    );
                }

                // Update timer on stat bar
                stat_bar_timer();
            
                if( level_timer == 0 )
                {
                    if( audio_mute != MUTE_STATUS_MUTE_ALL )
                    {
                        AUDIO.src = AUDIO_EVIL_LAUGH;
                        AUDIO.play();
                    }

                    // Create new enemy: Dr Horrible!
                    let dr_h = sprite(
                            "enemy_sprite_" + enemy_sprites.length,
                            player_start_char_i * PX_PER_CHAR_HOZ,
                            player_start_char_j * PX_PER_CHAR_VERT,
                            ASCII_DATA[DR_H_ASCII],
                            DR_H_COL,
                            SPRITE_TYPE_DR_H
                        );
        
                    // Add extra variables for dr_h sprite
                    dr_h['char_i'] = player_start_char_i;
                    dr_h['char_j'] = player_start_char_j;
              
                    dr_h['dir'] = DIR_NONE;
                    dr_h['ticks_per_move'] = 100;
                    dr_h['prev_move_ticks'] = -1;

                    enemy_sprites.push( dr_h );
                    all_sprites.push( dr_h );
                    
                    console.log( "Out of time" );
                }
            }
        }

        // Check for player collision with enemy sprite(s)
        if( check_for_player_enemy_collision() ) { return; }

        // Calculate ticks elapsed since last player move
        const TICKS_SINCE_LAST_PLAYER_MOVE
            = player_sprite.prev_move_ticks < 0 ?
                TICKS : TICKS - player_sprite.prev_move_ticks;
        
        // Check for floor below player sprite
        if( TICKS_SINCE_LAST_PLAYER_MOVE >= player_sprite.min_move_ticks )
        {
            if( !on_solid_ground( player_sprite ) )
            {
                // If falling, get next vertical char index
                const CH_J_BELOW = get_offset_j( player_sprite, 1 );
                
                // Add 'scent trail'
                get_char( player_sprite ).scent = DIR_DOWN; 

                // Move player to char below
                if( player_sprite.move_whole_chars(
                        player_sprite.char_i,
                        CH_J_BELOW )
                )
                {
                    // Play fall audio FX
                    if( audio_mute !== MUTE_STATUS_MUTE_ALL )
                    {
                        audio_move_fx_oscillator.frequency.value
                            = AUDIO_FX_FALL_FREQ_START
                                * Math.pow(
                                    AUDIO_FX_FALL_FREQ_INC,
                                    player_sprite.chars_fallen
                                );
                        audio_move_fx_oscillator
                            .connect( audio_move_fx_gain )
                                .connect( audio_context.destination);
                    }

                    // Update char position
                    player_sprite.char_j = CH_J_BELOW;

                    // Update number of chars fallen
                    player_sprite.chars_fallen += 1;

                    // Check for deadly player collisions
                    if( check_for_deadly_item_collision() ) { return; }
                    if( check_for_player_enemy_collision() ) { return; }
    
                    // Check for player collision with checkpoint
                    check_for_player_checkpoint();

                    // Check for collectable
                    // Note: this must be done *after* char indices
                    //       (i.e.. char_i and /or char_j) updated
                    check_for_collectable();

                    // Update previous move ticks
                    player_sprite.prev_move_ticks
                        = TICKS - player_sprite.min_move_ticks / 2;
                }
            }
            else if( player_sprite.chars_fallen >
                        player_sprite.max_fall_chars )
            {
                player_loses_life();
                return;
            }
            else
            {
                cancel_audio_move_FX();
                player_sprite.chars_fallen = 0;
            }
        }

        // Animate enemy sprites
        for( let n = 0; n < enemy_sprites.length; n++ )
        {
            // Get reference to enemy sprite
            const enemy = enemy_sprites[n];
            
            // Calculate ticks elapsed since last enemy move
            const TICKS_SINCE_LAST_ENEMY_MOVE
                = enemy.prev_move_ticks < 0 ?
                    TICKS : TICKS - enemy.prev_move_ticks;

            // If next move not due, move to next enemy sprite
            if( TICKS_SINCE_LAST_ENEMY_MOVE < enemy.ticks_per_move )
            {
                continue;
            }

            let offset_i = calc_i_offset( enemy.dir );
            let offset_j = calc_j_offset( enemy.dir );

            // Check if current direction valid and/or
            // decide on next direction.
            switch( enemy.type )
            {
                // Basic monster (left/right motion)
                case 1:

                    // Type 1 enemies reverse when reaching
                    // obstruction or end of platforms,
                    // so check for this
                    if( !on_solid_ground( enemy, offset_i, offset_j )
                        || !can_move( enemy, enemy.dir )
                    )
                    {
                        // Reverse direction for next move
                        enemy.dir = DIR_REVERSE[enemy.dir];
                    
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }
                    break;

                // Bat (random, non-homing motion)
                case 2:
                    {
                        // Get random digit 0-15 from time
                        const R = Date.now() & 0x0F;

                        // Type 2 enemies fly in a straight line
                        // then turn when reaching an obstruction
                        // but sometimes randomly change direction
                        if( R > 13 || !can_move( enemy, enemy.dir ) )
                        {
                            offset_i = 0;
                            offset_j = 0;

                            if ( R < 6 || R == 15 ) 
                            {
                                // Turn 90 deg anti-clockwise
                                enemy.dir = DIR_90_ANTI_CLOCKWISE[enemy.dir];
                            }
                            else if( R > 9 || R == 14 )
                            {
                                // Turn 90 deg clockwise
                                enemy.dir = DIR_90_CLOCKWISE[enemy.dir];
                            }
                            else
                            {
                                // Reverse direction
                                enemy.dir = DIR_REVERSE[enemy.dir];
                            }
                        }
                    }
                    break;

                // Arrows (return to start pos when hit obstruction)
                case 3:  // Left moving
                case 4:  // Right moving

                    if( !can_move( enemy, enemy.dir ) )
                    {
                        // Reset position using offsets
                        offset_i = enemy.start_char_i - enemy.char_i;
                        // Note: reseting 'j' shouldn't be
                        //       needed, but best be safe
                        offset_j = enemy.start_char_j - enemy.char_j;
                    }
                    break;

                // Ghost (semi-random, semi-homing motion)
                case 5:
                    {
                        // Get random digit 0-15 from time
                        const R = Date.now() & 0x0F;

                        if( R > 10 )
                        {
                            // Home in on player
                            home_in( enemy );
                        }
                        else
                        {
                            // Random direction
                            enemy.dir = R % 4;
                        }
                    }
                    break;

                // Acid drop (drops when player is directly
                // below and within line of sight)
                case 6:

                    // Check if drop waiting at start pos
                    if( enemy.dir !== DIR_DOWN )
                    {
                        // If yes, check for line-of-sight
                        // with player directly below
                        if( enemy.char_i == player_sprite.char_i
                            && enemy.char_j < player_sprite.char_j
                        )
                        {
                            // Loop over characters from droplet
                            // to player
                            let line_of_sight = true;
                            for( let j = enemy.char_j + 1;
                                 j <= player_sprite.char_j;
                                 j++
                            )
                            {
                                // Get character
                                const C = chars[j][enemy.char_i];

                                // Reject if character has solid top
                                if( 'solidity' in C
                                    && ( ( C.solidity & SOLID_TOP ) > 0 )
                                )
                                {
                                    line_of_sight = false;
                                    break;
                                }
                            }
                            // If has line of sight, start drop moving
                            if( line_of_sight )
                            {
                                enemy.dir = DIR_DOWN;
                                offset_j = 1;

                                // Remove move delay be reseting
                                // this value
                                enemy.ticks_per_move
                                    = ENEMY_TICKS_PER_MOVE[enemy.type - 1];
                            }

                        }
                    }
                    // Otherwise, move drop till solid surface reached
                    else
                    {
                        if( !can_move( enemy, enemy.dir ) )
                        {
                            offset_i = 0;
                            offset_j = enemy.start_char_j - enemy.char_j;
                            enemy.dir = DIR_NONE;

                            // Freeze droplet for one second
                            enemy.ticks_per_move = 1000;
                        }
                    }
                    break;

                // Roaming monster than randomly ascends/desends
                // ladders, but otherwise moves as basic monster
                case 13:
                case 7:
                    {
                        // Get random digit 0-15 from time
                        const R = Date.now() & 0x0F;
                    
                        // Get current direction
                        const DIR = enemy.dir;

                        // Get alternative directions
                        const REV_DIR = DIR_REVERSE[enemy.dir];
                        const CW_DIR = DIR_90_CLOCKWISE[enemy.dir];
                        const ACW_DIR = DIR_90_ANTI_CLOCKWISE[enemy.dir];

                        const CAN_MOVE_FWD
                            = can_move_on_solid_ground( enemy, DIR );

                        const CAN_GO_BACK
                            = can_move_on_solid_ground( enemy, REV_DIR );

                        const CAN_TURN_CW
                            = can_move_on_solid_ground( enemy, CW_DIR );

                        const CAN_TURN_ACW
                            = can_move_on_solid_ground( enemy, ACW_DIR );

                        if( ( CAN_TURN_CW || CAN_TURN_ACW )
                            && ( R < 8 || !CAN_MOVE_FWD )
                        )
                        {
                            if( CAN_TURN_CW && CAN_TURN_ACW )
                            {
                                enemy.dir = ( R % 2 == 0 ) ?
                                                CW_DIR : ACW_DIR;
                            }
                            else
                            {
                                enemy.dir = CAN_TURN_CW ?
                                                CW_DIR : ACW_DIR;
                            }
                        }
                        else if( !CAN_MOVE_FWD && CAN_GO_BACK )
                        {
                            enemy.dir = REV_DIR;
                        }

                        // Adjust offsets to match new direction
                        if( enemy.dir != DIR )
                        {
                            offset_i = calc_i_offset( enemy.dir );
                            offset_j = calc_j_offset( enemy.dir );
                        }
                    }
                    break;

                // Flys and floor traps (up/down, repetatively)
                case 8:  // Fly
                case 9:  // Faster moving fly
                case 10:  // Floor trap
                case 11:  // Faster moving floor trap
                    switch( enemy.dir )
                    {
                        case DIR_NONE: // Start direction defaults to 'down'
                        case DIR_DOWN:
                            enemy.dir = DIR_UP;
                            offset_j = 1;
                            break;

                        case DIR_UP:
                            enemy.dir = DIR_DOWN;
                            offset_j = -1;
                            break;
                        
                        default:
                            offset_i = 0;
                            offset_j = 0;
                            console.log( "Error: Fly/trap has incorrect",
                                         "direction", enemy.dir );
                    }
                    break;

                // Scorpion (moves as basic monster except falls
                // off end of platforms).
                case 12:

                    // Fall if char below is not solid
                    if( !on_solid_ground( enemy ) )
                    {
                        enemy.dir = DIR_DOWN;
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }
                    // Check for obstruction
                    else if( !can_move( enemy, enemy.dir ) )
                    {
                        if( enemy.dir == DIR_DOWN )
                        {
                            // If fall is broken, choose random
                            // left/right direction
                            enemy.dir = ( Date.now() & 0x0F ) < 7 ?
                                DIR_LEFT : DIR_RIGHT;
                        }
                        else
                        {
                            // Reverse if obstruction encountered
                            enemy.dir = DIR_REVERSE[enemy.dir];
                        }
                        offset_i = calc_i_offset( enemy.dir );
                        offset_j = calc_j_offset( enemy.dir );
                    }

                    break;

                // Dr. Horrible
                case SPRITE_TYPE_DR_H:

                    // Try to follow player scent
                    if( !follow_scent( enemy, offset_i, offset_j ) )
                    {
                        // If this fails, home in
                        home_in( enemy );
                    }
                    break;

                default:
                    console.log( "Error, unrecognized sprite type.");
                    continue;

            }  // End of switch block

            // Update previous move ticks, even if no
            // move actually takes place (this is to prevent
            // enemy sprites being processed every frame should
            // their movement be blocked in all directions).
            enemy.prev_move_ticks = TICKS;

            // If at least one offset is non-zero, move sprite
            if( offset_i != 0 || offset_j != 0 )
            {
                const NEW_I = get_offset_i( enemy, offset_i );
                const NEW_J = get_offset_j( enemy, offset_j );

                if( enemy.move_whole_chars( NEW_I, NEW_J ) )
                {
                    enemy.char_i = NEW_I;
                    enemy.char_j = NEW_J;
                
                    // Check for player collision
                    if( enemy.char_i == player_sprite.char_i
                        && enemy.char_j == player_sprite.char_j
                    )
                    {
                        // If collision, player loses life
                        player_loses_life();
                        return;
                    }
                }
            }
        }
    }

    // END OF MAIN LOOP
    //////////////////////////////////////


    // Create character object prototype
    character = function( i, j )
    {
        var char = new Object();
        
        char.char_id = 0;
        char.i = i;
        char.j = j;
        char.scent = DIR_NONE;
        char.solidity = 0;

        char.reset = function()
        {
            char.char_id = 0;
            char.scent = DIR_NONE;
            char.solidity = 0;
        }

        return char;
    }


    // Create sprite object prototype
    sprite = function(
        id,
        start_px_i,
        start_px_j,
        image = [],
        col = DEFAULT_FG_COL,
        type = SPRITE_TYPE_PLAYER
    )
    {
        if( image.length !== 8 )
        {
            console.log( "Error: image supplied for sprite has",
                         image.length, "rows, should be 8." );
            return;
        }

        var spr = new Object();

        // Find sprite height in virtual pixels
        const SPRITE_HEIGHT = image.length;

        // Find largest data line...
        let max_image_data_value = 0;
        for( let j = 0; j < SPRITE_HEIGHT; j++ )
        {
            max_image_data_value = Math.max(
                max_image_data_value,
                image[j]
            );
        }

        // ...and thereby sprite width in virtual pixels
        // Note: the '+ 0.00001' is there prevent round binary
        //       numbers (e.g. b10000000) being interpreted as
        //       one pixel smaller than they should be.
        const SPRITE_WIDTH
            = Math.ceil(
                Math.log2( max_image_data_value + 0.00001 )
            );

        // Create mini canvas just for this sprite
        spr.canvas = document.createElement( 'canvas' );
        spr.canvas.id = "sprite_canvas " + id;
        spr.canvas.width = SPRITE_WIDTH * PIXEL_WIDTH;
        spr.canvas.height = SPRITE_HEIGHT * PIXEL_HEIGHT;
        spr.ctx = spr.canvas.getContext( '2d' );

        // Set canvas positioning method to 'absolute',
        // i.e. relative to 'top_sprite_div'
        // Note: actual canvas position is set by spr.move, below
        spr.canvas.style.position = "absolute";

        // Set canvas background to transparent
        spr.ctx.fillStyle = "rgba( 0, 0, 0, 0 )";
        spr.ctx.fillRect( 0, 0, spr.canvas.width, spr.canvas.height );

        // Add canvas to 'div' that contains all sprites
        top_sprite_div.appendChild( spr.canvas );

        // Set fill colo(u)r for visible pixels
        spr.ctx.fillStyle = col;

        // Create sprite pixels (visible pixels only)
        for( let j = 0; j < SPRITE_HEIGHT; j++ )
        {
            const IMAGE_LINE = image[j];

            // Value used to extract a single bit from IMAGE_LINE
            let bit = Math.pow( 2, SPRITE_WIDTH - 1 );
            
            for( let i = 0; i < SPRITE_WIDTH; i++ )
            {
                if( IMAGE_LINE & bit )
                {
                    spr.ctx.fillRect(
                        i * PIXEL_WIDTH,
                        j * PIXEL_HEIGHT,
                        PIXEL_WIDTH,
                        PIXEL_HEIGHT
                    );
                }

                // Shift 'bit' right
                bit >>= 1;
            }
        }

        // Assign values to returnable object....

        // Record sprite type
        spr.type = type;

        // Current hoz pixel position of sprite's left boundary
        spr.px_left = start_px_i;

        // Current vert pixel position of sprite's top boundary
        spr.px_top = start_px_j;

        // Remember sprite width and height
        spr.px_width = SPRITE_WIDTH;
        spr.px_height = SPRITE_HEIGHT;

        // Current rightmost pixel of sprite
        spr.px_right = start_px_i + SPRITE_WIDTH;

        // Current bottom pixel of sprite
        spr.px_bottom = start_px_j + SPRITE_HEIGHT;

        // Remember current colo(u)r
        spr.col = col;
       
        spr.move_whole_chars = function( ch_i, ch_j, relative = false )
        {
            return spr.move( ch_i * PX_PER_CHAR_HOZ,
                       ch_j * PX_PER_CHAR_VERT,
                       relative );
        }

        spr.move_whole_chars_relative = function( ch_i, ch_j )
        {
            return spr.move_whole_chars( ch_i, ch_j, true );
        }

        spr.move_relative = function( px_i, px_j )
        {
            return spr.move( px_i, px_j, true );
        }

        spr.move = function( px_i, px_j, relative = false )
        {
            // If 'relative' option selected, set new position
            // offset from current position
            new_i = px_i;
            new_j = px_j;
            if( relative )
            {
                new_i += spr.px_left;
                new_j += spr.px_top;
            }

            // Return false if new position out-of-bounds
            if( new_i < 0
                || new_i >= PIXELS_WIDE
                || new_j < 0
                || new_j >= PIXELS_HIGH )
            {
                console.log( "New sprite pos (", new_i, new_j,
                             ") out of bounds." );
                return false;
            }

            // If ok, set new position
            spr.px_left = new_i;
            spr.px_top = new_j;

            // Update canvas position
            spr.canvas.style.left
                = PAD_LEFT + spr.px_left * PIXEL_WIDTH + "px";
            spr.canvas.style.top
                = PAD_TOP + spr.px_top * PIXEL_HEIGHT + "px";

            // Update bounds
            spr.px_right = spr.px_left + spr.px_width;
            spr.px_bottom = spr.px_top + spr.px_height;

            return true;
        }

        // Set position of sprite
        if( !spr.move( spr.px_left, spr.px_top ) )
        {
            // If desired position out-of-bounds, set to origin.
            spr.move( 0, 0 );
        }

        return spr;
    }

    //! Delete all sprite objects and associated 'div's
    /*! This also deletes 'top_sprite_div' */
    delete_all_sprites = function()
    {
        // Remove all 'div's associated with sprites
        if( top_sprite_div != 0 )
        {
            top_sprite_div.remove();
        }

        // Set 'top_sprite_div' reference to NULL
        top_sprite_div = 0;

        // Delete all sprite objects
        for( let n = 0; n < all_sprites.length; n++ )
        {
            delete all_sprites[n];
        }
        enemy_sprites = [];
        all_sprites = [];
        player_sprite = 0;
    }

    //! Check for player collision with deadly item
    check_for_deadly_item_collision = function()
    {
        if( LEVEL_DEADLY_ASCII_VALUES.has(
                get_char( player_sprite ).char_id
            )
        )
        {
            player_loses_life();
            return true;
        }

        // If no collision, return false
        return false;
    }

    //! Check for player collision with enemy sprite(s)
    check_for_player_enemy_collision = function()
    {
        // Store player's character indices locally
        const i = player_sprite.char_i;
        const j = player_sprite.char_j;

        for( let n = 0; n < enemy_sprites.length; n++ )
        {
            enemy = enemy_sprites[n];

            if( enemy.char_i == i && enemy.char_j == j )
            {
                // If collision, player loses life
                player_loses_life();
                return true;
            }
        }

        // If no collision, return false
        return false;
    }

    //! Check for player collision with checkpoint
    check_for_player_checkpoint = function()
    {
        if( get_char( player_sprite ).checkpoint )
        {
            player_sprite.last_checkpoint
                = [player_sprite.char_i,player_sprite.char_j];
        }
    }

    //! Check for player collision with collectable
    check_for_collectable = function()
    {
        // Get character object
        const new_char = get_char( player_sprite );

        // Check if character's ascii value is a collectable
        if( new_char.char_id == LEVEL_COLLECTABLE )
        {
            // If yes, check if character is in
            // collectable list
            if( collectables.has( new_char ) )
            {
                // If yes, remove from collectable list
                collectables.delete( new_char );

                // Change character's ascii to space,
                // using custom background colour if available
                const BG_COL = 'background' in custom_colors ?
                        custom_colors['background'] :
                        DEFAULT_BG_COL;
                draw_char( player_sprite.char_i,
                           player_sprite.char_j,
                           LEVEL_SPACE,
                           DEFAULT_FG_COL,
                           BG_COL
                );
                
                // Increase score
                player_score += 5;
                stat_bar_score();

                // Check for high score
                if( player_score > player_hi_score )
                {
                    player_hi_score = player_score;
                    stat_bar_hi_score();
                }

                // Check if more collectable items remain
                if( collectables.size > 0 )
                {
                    audio_play_collect_FX();
                }
                else
                {
                    console.log( "All items collected" );
                    
                    // Cancel any move sound FX
                    // and halt in-game theme
                    cancel_audio_move_FX();
                    audio_stop_theme();

                    // Play level completion fanfare
                    audio_play_tune(
                        audio_collect_fx_oscillator,
                        audio_collect_fx_gain,
                        AUDIO_FX_FANFARE_DATA
                    );

                    // Stop keyboard event handling
                    document.removeEventListener( 'keydown', handleKeyEvent );
                    key_handler_on = false;

                    // Stop main loop
                    clearInterval( main_loop_interval_id );
                    main_loop_interval_id = 0;

                    // Check for game completion
                    if( current_level >= NUM_LEVELS - 1 )
                    {
                        if( start_level > 0 )
                        {
                            // Game complete (with cheating)
                            game_state = GAME_STATE_GAME_COMPLETED_WITH_CHEATS;
                          
                            setTimeout( game_completion_screen, 1500 );
                        }
                        else
                        {
                            // Game complete (without cheating)
                            game_state = GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS;
                          
                            setTimeout( true_game_completion_screen, 1500 );
                        }
                    }
                    else
                    {
                        // Level complete
                        game_state = GAME_STATE_COMPLETED_LEVEL;
                        
                        setTimeout( level_completion_screen, 1500 );
                    }
                }
            }
            else
            {
                console.log( "Error, unlisted collectable ",
                             "found at ", player_sprite.char_i,
                             player_sprite.char_j, "ignoring." );
            }
        }
    }

    //! Initialize audio FX
    init_audio = function()
    {
        // Turn off mute
        audio_mute = MUTE_STATUS_FULL_AUDIO;
        stat_bar_mute();

        // Create audio context
        audio_context = new AudioContext();

        // Create move FX...

        // Create move FX oscillator instance
        audio_move_fx_oscillator = audio_context.createOscillator();
        audio_move_fx_oscillator.type = "square";
        audio_move_fx_oscillator.frequency.value = AUDIO_FX_MOVE_FREQ;
        
        // Start move FX oscillator
        audio_move_fx_oscillator.start();

        // Create move FX gain instance
        audio_move_fx_gain = audio_context.createGain();
        audio_move_fx_gain.gain.value = audio_master_gain;
        
        // Create collect FX...

        // Create collect FX oscillator instance
        audio_collect_fx_oscillator = audio_context.createOscillator();
        audio_collect_fx_oscillator.type = "triangle";
        audio_collect_fx_oscillator.frequency.value = AUDIO_FX_COLLECT_FREQ;
        
        // Start collect FX oscillator
        audio_collect_fx_oscillator.start();

        // Create collect FX gain instance
        audio_collect_fx_gain = audio_context.createGain();
        audio_collect_fx_gain.gain.value = audio_master_gain * 2;
        
        // Create timer alert FX...

        // Create alert FX oscillator instance
        audio_alert_fx_oscillator = audio_context.createOscillator();
        audio_alert_fx_oscillator.type = "triangle";
        audio_alert_fx_oscillator.frequency.value = AUDIO_FX_ALERT_FREQ;
        
        // Start alert FX oscillator
        audio_alert_fx_oscillator.start();

        // Create alert FX gain instance
        audio_alert_fx_gain = audio_context.createGain();
        audio_alert_fx_gain.gain.value = audio_master_gain * 4;

        // Create theme...

        // Create theme oscillator instance
        audio_theme_oscillator = audio_context.createOscillator();
        audio_theme_oscillator.type = "square";
        audio_theme_oscillator.frequency.value = 10;   // Low Hz
        
        // Start collect FX oscillator
        audio_theme_oscillator.start();

        // Create collect FX gain instance
        audio_theme_gain = audio_context.createGain();
        audio_theme_gain.gain.value = audio_master_gain;

        // If appropriate, start theme
        if( game_state !== GAME_STATE_IN_PLAY )
        {
            audio_play_tune(
                audio_theme_oscillator,
                audio_theme_gain,
                AUDIO_THEME_DATA,
                0,  // start pos
                true,  // repeat
                1.5  // speed
            );
        }
    }

    //! Play tune
    audio_play_tune = function(
        osc,
        gain,
        data,
        pos = 0,
        repeat = false,
        speed_ratio = 1.0,
        note_offset = 0
    )
    {
        let duration = 250;  // Default ticks to next callback
                             // when audio is muted.

        // If full mute (or FX only and not completion fanfare),
        // skip straight to callback, i.e. don't play note.
        if( ( audio_mute == MUTE_STATUS_FX_ONLY
                && osc == audio_collect_fx_oscillator )
            || audio_mute == MUTE_STATUS_FULL_AUDIO
        )
        {
            // Do this to prevent division by zero or negative durations
            if( speed_ratio <= 0 )
            {
                console.log( "Error: tune speed ratio <= 0, setting to 1." );
                speed_ratio = 1;
            }

            // Check for end of tune
            if( pos >= data.length )
            {
                if( repeat )
                {
                    // If repeat, reset 'pos'
                    pos = 0;
                }
                else
                {
                    // If no repeat, cancel previous note and return
                    if( osc.numberOfOutputs > 0 ) { osc.disconnect(); }
                    if( gain.numberOfOutputs > 0 ) { gain.disconnect(); }
                    console.log( "End of tune" );
                    return;
                }
            }

            // Get note ID and duration
            const NOTE_ID = data[pos][0] + note_offset;
            duration = data[pos][1] / speed_ratio;

            // Note ID zero (or less) is treated as silence
            if( NOTE_ID == 0 )
            {
                // console.log( "Playing pause", pos, NOTE_ID, duration );
                if( osc.type == "square" )
                {
                    // Stop previous note playing
                    if( osc.numberOfOutputs > 0 ) { osc.disconnect(); }
                    if( gain.numberOfOutputs > 0 ) { gain.disconnect(); }
                }
            }
            else
            {
                // console.log( "Playing note", pos, NOTE_ID, duration );

                // Set note freq
                if( osc.type == "sine" )
                {
                    // For smooth waveforms, change of freq
                    // requires smoothing
                    osc.frequency
                        .linearRampToValueAtTime(
                            440 * Math.pow( 2, ( NOTE_ID - 57 ) / 12 ),
                            audio_context.currentTime
                                // Note: convert duration to secs
                                 + duration / 1000 / 10
                        );
                }
                else
                {
                    // Otherwise, immediately change freq
                    osc.frequency.setValueAtTime(
                        440 * Math.pow( 2, ( NOTE_ID - 57 ) / 12 ),
                        audio_context.currentTime
                    );
                }

                // Set note playing
                osc.connect( gain ).connect( audio_context.destination );
            }   
        }

        // For in-game theme, speed up when timer is low
        if( game_state == GAME_STATE_IN_PLAY
            && level_timer < 20
        )
        {
            duration *= 0.75;
        }

        // Create call to play next note
        const CALLBACK = setTimeout(
            function()
            {
                audio_play_tune(
                    osc,
                    gain,
                    data,
                    pos + 1,
                    repeat,
                    speed_ratio,
                    note_offset
                );
            },
            duration
        );

        // If this is theme, store callback, otherwise ignore
        if( osc == audio_theme_oscillator )
        {
            audio_theme_callback = CALLBACK;
        }
    }

    //! Play item collection / bonus score FX
    audio_play_collect_FX = function()
    {
        if( audio_mute == MUTE_STATUS_MUTE_ALL ) { return; }

        audio_collect_fx_oscillator
            .frequency
                .setValueAtTime(
                    AUDIO_FX_COLLECT_FREQ,
                    audio_context.currentTime
                );
        audio_collect_fx_oscillator
            .frequency
                .linearRampToValueAtTime(
                    AUDIO_FX_COLLECT_FREQ * 2,
                    audio_context.currentTime
                        // Note: convert duration to secs
                        + AUDIO_FX_COLLECT_DURATION / 1000
                );
        audio_collect_fx_oscillator
            .connect( audio_collect_fx_gain )
                .connect( audio_context.destination);
        setTimeout(
            function () { cancel_audio_collect_FX(); },
            AUDIO_FX_COLLECT_DURATION
        );
    }

    //! Stop theme playing
    audio_stop_theme = function()
    {
        if( audio_theme_callback !== 0 )
        {
            clearTimeout( audio_theme_callback );
            audio_theme_callback = 0;
        }
        if( audio_theme_oscillator.numberOfOutputs > 0 )
        {
            audio_theme_oscillator.disconnect();
        }
        if( audio_theme_gain.numberOfOutputs > 0 )
        {
            audio_theme_gain.disconnect();
        }
    }

    //! Cancel move audio FX
    cancel_audio_move_FX = function()
    {
        if( audio_move_fx_oscillator.numberOfOutputs > 0 )
        {
            audio_move_fx_oscillator.disconnect();
        }
        if( audio_move_fx_gain.numberOfOutputs > 0 )
        {
            audio_move_fx_gain.disconnect();
        }
    }

    //! Cancel collect audio FX
    cancel_audio_collect_FX = function()
    {
        if( audio_collect_fx_oscillator.numberOfOutputs > 0 )
        {
            audio_collect_fx_oscillator.disconnect();
        }
        if( audio_collect_fx_gain.numberOfOutputs > 0 )
        {
            audio_collect_fx_gain.disconnect();
        }
    }

    //! Cancel alert audio FX
    cancel_audio_alert_FX = function()
    {
        if( audio_alert_fx_oscillator.numberOfOutputs > 0 )
        {
            audio_alert_fx_oscillator.disconnect();
        }
        if( audio_alert_fx_gain.numberOfOutputs > 0 )
        {
            audio_alert_fx_gain.disconnect();
        }
    }

    //! Cancel all FX (except theme)
    cancel_audio_FX = function()
    {
        cancel_audio_move_FX();
        cancel_audio_collect_FX();
        cancel_audio_alert_FX();
    };

    calc = function( n1, n2, n3, n4 )
    {
        return n1 - n4 + ( n2 - n4 ) * 32 + ( n3 - n4 ) * 1024;
    }

    recalc = function( n )
    {
        return String.fromCharCode( ( n & 31 ) + 65 )
               + String.fromCharCode( ( ( n >> 5 ) & 31 ) + 65 )
               + String.fromCharCode( ( ( n >> 10 ) & 31 ) + 65 );
    }

    //! Pause game (only while in play state)
    pause = function( update_stat_bar = true )
    {
        // Ignore request if game not in play state
        if( game_state != GAME_STATE_IN_PLAY ) { return; }

        console.log( "Game paused" );
        game_state = GAME_STATE_PLAY_PAUSED;

        cancel_audio_FX();

        if( update_stat_bar )
        {
            stat_bar_alert( "PAUSED", "black", "cyan" );
        }

        // Remember time paused
        level_pause_ticks = Date.now();

        // Stop main loop
        clearInterval( main_loop_interval_id );
        main_loop_interval_id = 0;
    }

    //! Unpause game (only while in pause state)
    unpause = function()
    {
        // Ignore request if game not in pause state
        if( game_state != GAME_STATE_PLAY_PAUSED ) { return; }

        console.log( "Game unpaused" );
        game_state = GAME_STATE_IN_PLAY;

        stat_bar_update();

        // Calculate time spent in pause
        if( level_pause_ticks > 0 )
        {
            level_pause_total_ticks
                += Date.now() - level_pause_ticks;
            level_pause_ticks = 0;
        }

        // Restart main loop
        main_loop_interval_id
            = setInterval( main_loop, FRAME_DURATION ); 
    }

    //! Mute audio (during any game state)
    mute = function()
    {
        console.log( "Mute all" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_MUTE_ALL;

        cancel_audio_FX();
        audio_master_gain = 0;
        audio_theme_gain.disconnect();
        stat_bar_mute();
    }

    //! Mute theme (play FX only)
    mute_theme = function()
    {
        console.log( "Mute theme, play FX" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_FX_ONLY;

        cancel_audio_FX();
        audio_master_gain = AUDIO_DEFAULT_GAIN;
        audio_theme_gain.disconnect();
        stat_bar_mute();
    }

    //! Unmute audio (during any game state)
    unmute = function()
    {
        console.log( "Unmute all" );
        
        // This is usually set by calling program,
        // but better safe than sorry
        audio_mute = MUTE_STATUS_FULL_AUDIO;

        audio_master_gain = AUDIO_DEFAULT_GAIN;
        
        // Set tune's gain according to waveform type
        if( audio_theme_oscillator.type == "sine" )
        {
            audio_theme_gain.gain.value
                = audio_master_gain * AUDIO_THEME_IN_GAME_GAIN;
        }
        else
        {
            audio_theme_gain.gain.value = audio_master_gain;
        }

        audio_theme_gain.connect( audio_context.destination );
        stat_bar_mute();
    }

    //! Follow player 'scent trial' (at location offset from enemy)
    follow_scent = function( enemy, offset_i = 0, offset_j = 0 )
    {
        // Get player 'scent trail' at enemy's next position
        const NEW_DIR = get_char( enemy, offset_i, offset_j ).scent;
        
        // If scent direction valid, use this
        if( NEW_DIR !== DIR_NONE )
        {
            enemy.dir = NEW_DIR;

            // Return success
            return true;
        }

        // Otherwise, return failure
        return false;
    }

    //! Home in on player
    home_in = function( enemy )
    {
        // Get difference between player and enemy locations
        const DIFF_I = player_sprite.char_i - enemy.char_i;
        const DIFF_J = player_sprite.char_j - enemy.char_j;

        // Determine whether required direction is hoz and/or vert
        let hoz_flag = DIFF_I != 0;
        let vert_flag = DIFF_J != 0;
        
        // As diagonal movement not allowed,
        // if both hoz and vert identified, select one
        // depending on current ticks
        if( hoz_flag && vert_flag )
        {
            if( Date.now() % 2 == 0 ) { hoz_flag = false; }
            else { vert_flag = false; }
        }

        if( hoz_flag )
        {
            enemy.dir = DIFF_I < 0 ? DIR_LEFT : DIR_RIGHT;
        }

        if( vert_flag )
        {
            enemy.dir = DIFF_J < 0 ? DIR_UP : DIR_DOWN;
        }
    }

    ///////////////////////////////////////////
    // CANVAS FUNCTIONS
    
    //! Clear canvas
    clear_canvas = function(
        ctx,
        char_array,
        bg_col = DEFAULT_BG_COL  )
    {
        // Clear canvas
        ctx.fillStyle = bg_col; 
        ctx.fillRect(
            0,
            0,
            TOTAL_CHAR_WIDTH,
            TOTAL_CHAR_HEIGHT
        ); 

        // Return char array to default state
        for( let j = 0; j < char_array.length; j++ )
        {
            const LINE = char_array[j];

            for( let i = 0; i < LINE.length; i++ )
            {
                LINE[i].reset();
            }
        }
    }

    //! Draw char onto main game canvas
    draw_char = function( 
        i,  // Hoz pos (in whole chars)
        j,  // Vert pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        draw_char_canvas( CANV_CHARS_CTX, chars, i, j, c, fg_col, bg_col );
    }

    //! Draw char onto stat bar canvas
    draw_char_sb = function( 
        i,  // Hoz pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        draw_char_canvas( CANV_SB_CTX, sb_chars, i, 0, c, fg_col, bg_col );
    }

    //! Draw char onto canvas
    draw_char_canvas = function(
        ctx,
        char_array,  // 'character' array
        i,  // Hoz pos (in whole chars)
        j,  // Vert pos (in whole chars)
        c,  // ASCII value
        fg_col = DEFAULT_FG_COL,
        bg_col = DEFAULT_BG_COL
    )
    {
        if( !char_qual_check( c ) )
        {
            console.log( "Error: char with ascii code",
                         c, " at", i, j,
                         "has problem with graphic data." );

            if( !char_qual_check( INVALID_ASCII ) ) { return; }
            
            // Use alternate ascii code
            c = INVALID_ASCII;
        }

        // Update character array
        char_array[j][i].char_id = c;

        // Calculate pixel indices of char's top-left corner
        const BASE_PX_I = PX_PER_CHAR_HOZ * i;
        const BASE_PX_J = PX_PER_CHAR_VERT * j;
        
        // Get reference to char image data array
        const CHAR_DATA = ASCII_DATA[c];

        for( let m = 0; m < PX_PER_CHAR_VERT; m++ )
        {
            // Calculate vert pos in virtual pixels
            const PX_J = BASE_PX_J + m;

            // Calculate vert pos in screen pixels
            // from top-left of canvas
            const Y = PX_J * PIXEL_HEIGHT;

            // Get single line of char image
            const CHAR_DATA_LINE = CHAR_DATA[ m ];

            // Value used to extract a single bit from CHAR_LINE
            let bit = Math.pow( 2, PX_PER_CHAR_HOZ - 1 );

            for( let n = 0; n < PX_PER_CHAR_HOZ; n++ )
            {
                // Calculate hoz pos in virtual pixels
                const PX_I = BASE_PX_I + n;

                // Calculate hoz pos in screen pixels
                // from top-left of canvas
                const X = PX_I * PIXEL_WIDTH;

                // Draw pixel
                ctx.fillStyle 
                        = ( CHAR_DATA_LINE & bit ) ? fg_col : bg_col;
                ctx.fillRect( X, Y, PIXEL_WIDTH, PIXEL_HEIGHT );

                // Shift 'bit' right
                bit >>= 1;
            }
        }
    }

    // END OF FUNCTION DEFS
    ///////////////////////////////////////////


    ///////////////////////////////////////////
    // CREATE EVENT HANDLER(S)

    mouse_init_audio = function()
    {
        // Make sure this is only called once
        if( audio_context != 0
            || game_state != GAME_STATE_AWAITING_MOUSE_CLICK
        ) { return; }
        
        console.log( "mouse_init_audio" );

        // Initialize audio
        init_audio();

        // Remove click listener as no longer required
        document.removeEventListener( 'click', mouse_init_audio );

        // Start game by launching title screen
        title_screen( 'cyan', PIXELS_WIDE, 102, 32 );
    }

    handleKeyEvent = function(e)
    {
        // Initialize audio context and oscilator only once 
        // a key has been pressed, as many browsers forbid
        // audio from playing unless the user has interacted
        // with the web page
        if( audio_context == 0 ) { init_audio(); }

        // Get key code
        const C = `${e.code}`;
           
        // Check for mute
        if( C == "KeyM" )
        {
            audio_mute = ( audio_mute + 1 ) % MUTE_STATUS_MAX;

            switch( audio_mute )
            {
                case MUTE_STATUS_FULL_AUDIO:
                    unmute();
                    break;

                case MUTE_STATUS_FX_ONLY:
                    mute_theme();
                    break;

                case MUTE_STATUS_MUTE_ALL:
                    mute();
                    break;

                default:
                    console.log( "Error: unknown mute status:",
                                 audio_mute );
            }

            return;
        }

        // Check for in-game quit key
        if( game_state == GAME_STATE_IN_PLAY
            && C == "Escape"
        )
        {
            // Pause game (no need to update stat bar here)
            pause( false );

            game_state = GAME_STATE_QUIT_OPTION;

            // Confirm quit question on stat bar
            stat_bar_alert( "Quit game (y/n)" );

            return;
        }

        // If in bonus award phase, ignore all other keystrokes
        if( game_state == GAME_STATE_COMPLETED_LEVEL )
        {
            return;
        }

        // Check for in-game level restart key
        if( game_state == GAME_STATE_IN_PLAY
            && player_lives > 1  // This option costs a life
            && C == "KeyR"
        )
        {
            // Pause game (no need to update stat bar here)
            pause( false );

            game_state = GAME_STATE_RESTART_OPTION;

            // Confirm quit question on stat bar
            stat_bar_alert( "Restart level (y/n)" );

            return;
        }

        // If key handling delay, ignore key stoke for now
        if( key_handling_delay ) { return; }

        // If game is in play, process key actions
        if( game_state == GAME_STATE_IN_PLAY )
        {
            // Get current time, in ticks
            const TICKS = Date.now();
            
            // Calculate ticks elapsed since last player move
            const TICKS_SINCE_LAST_PLAYER_MOVE
                = player_sprite.prev_move_ticks < 0 ?
                    TICKS : TICKS - player_sprite.prev_move_ticks;
           
            // Check for pause
            if( C == "KeyP" )
            {
                pause();
                return;
            }

            let successful_move = false;
            if( player_sprite.chars_fallen == 0 )
            {

                // Move right
                if ( ( C == "KeyD" || C == "KeyL" || C == "ArrowRight" )
                     && can_move_right( player_sprite )
                     && ( on_solid_ground( player_sprite )
                          // This clause permits hoz 'jump' mid-air
                          || ( player_sprite.last_move_up 
                               && TICKS_SINCE_LAST_PLAYER_MOVE
                                     <  player_sprite.min_move_ticks * 2                              
                             )      
                     )
                )
                {
                    // Add 'scent trail'
                    get_char( player_sprite ).scent = DIR_RIGHT;

                    if( player_sprite.move_whole_chars_relative( 1, 0 ) )
                    {
                        // If move successful, adjust char position
                        player_sprite.char_i += 1;

                        player_sprite.last_move_up = false;
            
                        successful_move = true;
                    }
                }
                // Move left
                else if ( ( C == "KeyA" || C == "KeyJ" || C == "ArrowLeft" )
                          && can_move_left( player_sprite )
                          && ( on_solid_ground( player_sprite )
                               // This clause permits hoz 'jump' mid-air
                               || ( player_sprite.last_move_up 
                                    && TICKS_SINCE_LAST_PLAYER_MOVE
                                          <  player_sprite.min_move_ticks * 2                              
                                  )
                          )
                )
                {
                    // Add 'scent trail'
                    get_char( player_sprite ).scent = DIR_LEFT;

                    if( player_sprite.move_whole_chars_relative( -1, 0 ) )
                    {
                        // If move successful, adjust char position
                        player_sprite.char_i -= 1;

                        player_sprite.last_move_up = false;

                        successful_move = true;
                    }
                }
                // Move down
                else if ( ( C == "KeyS" || C == "KeyK" || C == "ArrowDown" )
                          && can_descend( player_sprite )
                )
                {
                    // Add 'scent trail'
                    get_char( player_sprite ).scent = DIR_DOWN;

                    if( player_sprite.move_whole_chars_relative( 0, 1 ) )
                    {
                        // If move successful, adjust char position
                        player_sprite.char_j += 1;

                        player_sprite.last_move_up = false;

                        successful_move = true;
                    }
                }
                // Move up
                else if ( ( C == "KeyW" || C == "KeyI" || C == "ArrowUp" )
                          && on_solid_ground( player_sprite )
                          && can_move( player_sprite, DIR_UP )
                )
                {
                    // Add 'scent trail'
                    get_char( player_sprite ).scent = DIR_UP;

                    if( player_sprite.move_whole_chars_relative( 0, -1 ) )
                    {
                        // If move successful, adjust char position
                        player_sprite.char_j -= 1;

                        player_sprite.last_move_up = true;

                        successful_move = true;
                    }
                }
            }

            // Post move processing
            if( successful_move )
            {
                // Check for deadly player collisions
                if( check_for_deadly_item_collision() ) { return; }
                if( check_for_player_enemy_collision() ) { return; }

                // Check for player collision with checkpoint
                check_for_player_checkpoint();

                // Check for collectable
                // Note: this must be done *after* char indices
                //       (i.e.. char_i and /or char_j) updated
                check_for_collectable();

                // Update time of last move
                player_sprite.prev_move_ticks = TICKS;
            }
        }  // End of in-play key handling
        else 
        {
            // Handle non-play keypress events
            switch( game_state )
            {
                case GAME_STATE_PLAY_PAUSED:
                        if( C == "KeyP" )
                        {
                            unpause();
                            return;
                        }
                        break;
                        
                case GAME_STATE_TITLE:
                    if ( C == "Space" ) { blerb_screen(); }
                    break;

                case GAME_STATE_BLERB:
                    if ( C == "Space" ) { menu_screen(); }
                    break;

                case GAME_STATE_MENU:
                    switch( C )
                    {
                        case "Digit1":
                            instruction_screen_1();
                            break;

                        case "Digit2":
                            player_lives = PLAYER_START_LIVES;
                            player_score = 0;
                            current_level = 0;
                            start_level = 0;
                            level_intro_screen( 0 );
                            break;

                        case "Digit3":
                            select_level_screen();
                            break;

                        case "Digit4":
                            about_screen();
                            break;

                        default:
                            // DEBUG
                            console.log( "Unrecognized menu choice", C );
                            return;
                    }
                
                case GAME_STATE_INSTRUCTIONS_1:
                    if ( C == "Space" ) { instruction_screen_2(); }
                    break;

                case GAME_STATE_INSTRUCTIONS_2:
                    if ( C == "Space" ) { instruction_screen_3(); }
                    break;

                case GAME_STATE_INSTRUCTIONS_3:
                    if ( C == "Space" ) { menu_screen(); }
                    break;

                case GAME_STATE_SELECT_LEVEL:
                    select_level( C );
                    break;

                case GAME_STATE_ABOUT:
                    if( C == "Space" || C == "Escape" )
                    {
                        menu_screen();
                    }
                    break;

                case GAME_STATE_LEVEL_INTRO:
                    if ( C == "Space" )
                    {
                        audio_stop_theme();
                        draw_level( current_level );
                    }
                    break;

                case GAME_STATE_GAME_OVER:
                    if ( C == "Space" ) { menu_screen(); }
                    break;

                case GAME_STATE_BONUS_FINISHED:
                    if( C == "Space" )
                    {
                        level_intro_screen( current_level );
                    }
                    break;

                case GAME_STATE_QUIT_OPTION:
                    if( C == "KeyY" )
                    {
                        game_over_screen();
                        return;
                    }
                    else if( C == "KeyN" )
                    {
                        // This is important otherwise
                        // 'unpause' will ignore request
                        game_state = GAME_STATE_PLAY_PAUSED;

                        // Restart game
                        unpause();

                        return;
                    }
                    break;

                case GAME_STATE_RESTART_OPTION:
                    if( C == "KeyY" )
                    {
                        // Return game status to in-play
                        // (this must be done before stat
                        //  bar is updated)
                        game_state = GAME_STATE_IN_PLAY;

                        // Return stat bar to normal status
                        stat_bar_update();

                        // Call life lost routine with
                        // 'true' parameter to indicate level
                        // restart required
                        player_loses_life( true );
                        return;
                    }
                    else if( C == "KeyN" )
                    {
                        // This is important otherwise
                        // 'unpause' will ignore request
                        game_state = GAME_STATE_PLAY_PAUSED;

                        // Restart game
                        unpause();

                        return;
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_WITH_CHEATS:
                    if ( C == "Space" )
                    {
                        audio_stop_theme();
                        menu_screen();
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_WITHOUT_CHEATS:
                    if ( C == "Space" )
                    {
                        audio_stop_theme();
                        menu_screen();
                    }
                    break;

                case GAME_STATE_GAME_COMPLETED_SEQUENCE:
                    // No action
                    break;

                default:
                    console.log( "Defaulting draw_level'." );
                    draw_level( 0 );
            }
        }
    }

    // END OF EVENT HANDLERS

    ///////////////////////////////////////////
    // PRE-SIZE CHARACTER arrays

    // Create (empty) array to hold main play area characters
    for( let j = 0; j < CHARS_HIGH; j++ )
    {
        // Add new line to char array
        chars.push( [] );

        // Get reference to line
        const LINE = chars[j];

        // Add new char to line
        for( let i = 0; i < CHARS_WIDE ; i++ )
        {
            LINE.push( new character( i, j ) );
        }
    }
    
    // Create (empty) array to hold stat bar characters
    {
        // Add one line to char array
        sb_chars.push( [] );

        // Get reference to line
        const LINE = sb_chars[0];

        // Add new char to line
        for( let i = 0; i < CHARS_WIDE; i++ )
        {
            LINE.push( new character( i, 0 ) );
        }
    }
           
    /////////////////////////////////////////////////
    // GAME LAUNCHES FROM HERE
    mouse_activation_screen();
    /////////////////////////////////////////////////
}
</script>
<body padding="0px 0px 0px 0px"><div></div></body>
</html>
